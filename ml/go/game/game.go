/*
cgo stubs for package game.
File is generated by gopy. Do not edit.
gopy pkg -exclude=model,ml1,ml2,moveml ../../internal/game ../../internal/bot context encoding/json
*/

package main

/*

#cgo CFLAGS: "-I/usr/include/python3.9" -Wno-error -Wno-implicit-function-declaration -Wno-int-conversion
#cgo LDFLAGS: "-L/usr/lib" "-lpython3.9" -lcrypt -ldl  -lm -lm

// #define Py_LIMITED_API // need full API for PyRun*
#include <Python.h>
typedef uint8_t bool;
// static inline is trick for avoiding need for extra .c file
// the following are used for build value -- switch on reflect.Kind
// or the types equivalent
static inline PyObject* gopy_build_bool(uint8_t val) {
	return Py_BuildValue("b", val);
}
static inline PyObject* gopy_build_int64(int64_t val) {
	return Py_BuildValue("k", val);
}
static inline PyObject* gopy_build_uint64(uint64_t val) {
	return Py_BuildValue("K", val);
}
static inline PyObject* gopy_build_float64(double val) {
	return Py_BuildValue("d", val);
}
static inline PyObject* gopy_build_string(const char* val) {
	return Py_BuildValue("s", val);
}
static inline void gopy_decref(PyObject* obj) { // macro
	Py_XDECREF(obj);
}
static inline void gopy_incref(PyObject* obj) { // macro
	Py_XINCREF(obj);
}
static inline int gopy_method_check(PyObject* obj) { // macro
	return PyMethod_Check(obj);
}
static inline void gopy_err_handle() {
	if(PyErr_Occurred() != NULL) {
		PyErr_Print();
	}
}

*/
import "C"
import (
	"errors"

	"github.com/go-python/gopy/gopyh" // handler

	"bytes"
	"context"
	"encoding/json"
	"io"
	"reflect"
	"unsafe"

	"github.com/ShmaykhelDuo/battler/internal/bot"
	"github.com/ShmaykhelDuo/battler/internal/bot/minimax"
	"github.com/ShmaykhelDuo/battler/internal/bot/ml"
	"github.com/ShmaykhelDuo/battler/internal/bot/ml/formats"
	"github.com/ShmaykhelDuo/battler/internal/game"
	"github.com/ShmaykhelDuo/battler/internal/game/characters"
	"github.com/ShmaykhelDuo/battler/internal/game/characters/euphoria"
	"github.com/ShmaykhelDuo/battler/internal/game/characters/milana"
	"github.com/ShmaykhelDuo/battler/internal/game/characters/ruby"
	"github.com/ShmaykhelDuo/battler/internal/game/characters/speed"
	"github.com/ShmaykhelDuo/battler/internal/game/characters/storyteller"
	"github.com/ShmaykhelDuo/battler/internal/game/characters/structure"
	"github.com/ShmaykhelDuo/battler/internal/game/characters/z89"
	"github.com/ShmaykhelDuo/battler/internal/game/common"
	"github.com/ShmaykhelDuo/battler/internal/game/gametest"
	"github.com/ShmaykhelDuo/battler/internal/game/match"
)

// main doesn't do anything in lib / pkg mode, but is essential for exe mode
func main() {

}

// initialization functions -- can be called from python after library is loaded
// GoPyInitRunFile runs a separate python file -- call in GoPyInit if it
// steals the main thread e.g., for GUI event loop, as in GoGi startup.

//export GoPyInit
func GoPyInit() {

}

// type for the handle -- int64 for speed (can switch to string)
type GoHandle int64
type CGoHandle C.longlong

// DecRef decrements the reference count for the specified handle
// and deletes it it goes to zero.
//
//export DecRef
func DecRef(handle CGoHandle) {
	gopyh.DecRef(gopyh.CGoHandle(handle))
}

// IncRef increments the reference count for the specified handle.
//
//export IncRef
func IncRef(handle CGoHandle) {
	gopyh.IncRef(gopyh.CGoHandle(handle))
}

// NumHandles returns the number of handles currently in use.
//
//export NumHandles
func NumHandles() int {
	return gopyh.NumHandles()
}

// boolGoToPy converts a Go bool to python-compatible C.char
func boolGoToPy(b bool) C.char {
	if b {
		return 1
	}
	return 0
}

// boolPyToGo converts a python-compatible C.Char to Go bool
func boolPyToGo(b C.char) bool {
	if b != 0 {
		return true
	}
	return false
}

func complex64GoToPy(c complex64) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex64PyToGo(o *C.PyObject) complex64 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float32(v.real), float32(v.imag))
}

func complex128GoToPy(c complex128) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex128PyToGo(o *C.PyObject) complex128 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float64(v.real), float64(v.imag))
}

// errorGoToPy converts a Go error to python-compatible C.CString
func errorGoToPy(e error) *C.char {
	if e != nil {
		return C.CString(e.Error())
	}
	return C.CString("")
}

// --- generated code for package: game below: ---

// ---- External Types Outside of Targeted Packages ---

// Converters for pointer handles for type: *bytes.Buffer
func ptrFromHandle_Ptr_bytes_Buffer(h CGoHandle) *bytes.Buffer {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*bytes.Buffer")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(bytes.Buffer{})).(*bytes.Buffer)
}
func handleFromPtr_Ptr_bytes_Buffer(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*bytes.Buffer", p))
}

// Converters for pointer handles for type: *reflect.MapIter
func ptrFromHandle_Ptr_reflect_MapIter(h CGoHandle) *reflect.MapIter {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*reflect.MapIter")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(reflect.MapIter{})).(*reflect.MapIter)
}
func handleFromPtr_Ptr_reflect_MapIter(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*reflect.MapIter", p))
}

// Converters for non-pointer handles for type: bytes.Buffer
func ptrFromHandle_bytes_Buffer(h CGoHandle) *bytes.Buffer {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "bytes.Buffer")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(bytes.Buffer{})).(*bytes.Buffer)
}
func handleFromPtr_bytes_Buffer(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("bytes.Buffer", p))
}

// Converters for pointer handles for type: io.Reader
func ptrFromHandle_io_Reader(h CGoHandle) io.Reader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "io.Reader")
	if p == nil {
		return nil
	}
	return p.(io.Reader)
}
func handleFromPtr_io_Reader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("io.Reader", p))
}

// Converters for pointer handles for type: io.Writer
func ptrFromHandle_io_Writer(h CGoHandle) io.Writer {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "io.Writer")
	if p == nil {
		return nil
	}
	return p.(io.Writer)
}
func handleFromPtr_io_Writer(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("io.Writer", p))
}

// Converters for non-pointer handles for type: reflect.MapIter
func ptrFromHandle_reflect_MapIter(h CGoHandle) *reflect.MapIter {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "reflect.MapIter")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(reflect.MapIter{})).(*reflect.MapIter)
}
func handleFromPtr_reflect_MapIter(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("reflect.MapIter", p))
}

// Converters for non-pointer handles for type: reflect.StructField
func ptrFromHandle_reflect_StructField(h CGoHandle) *reflect.StructField {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "reflect.StructField")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(reflect.StructField{})).(*reflect.StructField)
}
func handleFromPtr_reflect_StructField(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("reflect.StructField", p))
}

// Converters for pointer handles for type: reflect.Type
func ptrFromHandle_reflect_Type(h CGoHandle) reflect.Type {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "reflect.Type")
	if p == nil {
		return nil
	}
	return p.(reflect.Type)
}
func handleFromPtr_reflect_Type(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("reflect.Type", p))
}

// Converters for non-pointer handles for type: reflect.Value
func ptrFromHandle_reflect_Value(h CGoHandle) *reflect.Value {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "reflect.Value")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(reflect.Value{})).(*reflect.Value)
}
func handleFromPtr_reflect_Value(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("reflect.Value", p))
}

// ---- Package: go ---

// ---- Types ---

// Converters for implicit pointer handles for type: []bool
func ptrFromHandle_Slice_bool(h CGoHandle) *[]bool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]bool")
	if p == nil {
		return nil
	}
	return p.(*[]bool)
}
func deptrFromHandle_Slice_bool(h CGoHandle) []bool {
	p := ptrFromHandle_Slice_bool(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_bool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]bool", p))
}

// --- wrapping slice: []bool ---
//
//export Slice_bool_CTor
func Slice_bool_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_bool(&[]bool{}))
}

//export Slice_bool_len
func Slice_bool_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_bool(handle))
}

//export Slice_bool_elem
func Slice_bool_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_bool(handle)
	return boolGoToPy(s[_idx])
}

//export Slice_bool_subslice
func Slice_bool_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_bool(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_bool(&ss))
}

//export Slice_bool_set
func Slice_bool_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_bool(handle)
	s[_idx] = boolPyToGo(_vl)
}

//export Slice_bool_append
func Slice_bool_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_bool(handle)
	*s = append(*s, boolPyToGo(_vl))
}

// Converters for implicit pointer handles for type: []byte
func ptrFromHandle_Slice_byte(h CGoHandle) *[]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]byte")
	if p == nil {
		return nil
	}
	return p.(*[]byte)
}
func deptrFromHandle_Slice_byte(h CGoHandle) []byte {
	p := ptrFromHandle_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]byte", p))
}

// --- wrapping slice: []byte ---
//
//export Slice_byte_CTor
func Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_byte(&[]byte{}))
}

//export Slice_byte_len
func Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_byte(handle))
}

//export Slice_byte_elem
func Slice_byte_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_byte(handle)
	return C.char(s[_idx])
}

//export Slice_byte_subslice
func Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_byte(&ss))
}

//export Slice_byte_set
func Slice_byte_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_byte(handle)
	s[_idx] = byte(_vl)
}

//export Slice_byte_append
func Slice_byte_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_byte(handle)
	*s = append(*s, byte(_vl))
}

//export Slice_byte_from_bytes
func Slice_byte_from_bytes(o *C.PyObject) CGoHandle {
	size := C.PyBytes_Size(o)
	ptr := unsafe.Pointer(C.PyBytes_AsString(o))
	data := make([]byte, size)
	tmp := unsafe.Slice((*byte)(ptr), size)
	copy(data, tmp)
	return handleFromPtr_Slice_byte(&data)
}

//export Slice_byte_to_bytes
func Slice_byte_to_bytes(handle CGoHandle) *C.PyObject {
	s := deptrFromHandle_Slice_byte(handle)
	ptr := unsafe.Pointer(&s[0])
	size := len(s)
	return C.PyBytes_FromStringAndSize((*C.char)(ptr), C.long(size))
}

// Converters for implicit pointer handles for type: []error
func ptrFromHandle_Slice_error(h CGoHandle) *[]error {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]error")
	if p == nil {
		return nil
	}
	return p.(*[]error)
}
func deptrFromHandle_Slice_error(h CGoHandle) []error {
	p := ptrFromHandle_Slice_error(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_error(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]error", p))
}

// --- wrapping slice: []error ---
//
//export Slice_error_CTor
func Slice_error_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_error(&[]error{}))
}

//export Slice_error_len
func Slice_error_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_error(handle))
}

//export Slice_error_elem
func Slice_error_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_error(handle)
	return errorGoToPy(s[_idx])
}

//export Slice_error_subslice
func Slice_error_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_error(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_error(&ss))
}

//export Slice_error_set
func Slice_error_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_error(handle)
	s[_idx] = errors.New(C.GoString(_vl))
}

//export Slice_error_append
func Slice_error_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_error(handle)
	*s = append(*s, errors.New(C.GoString(_vl)))
}

// Converters for implicit pointer handles for type: []float32
func ptrFromHandle_Slice_float32(h CGoHandle) *[]float32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float32")
	if p == nil {
		return nil
	}
	return p.(*[]float32)
}
func deptrFromHandle_Slice_float32(h CGoHandle) []float32 {
	p := ptrFromHandle_Slice_float32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float32", p))
}

// --- wrapping slice: []float32 ---
//
//export Slice_float32_CTor
func Slice_float32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float32(&[]float32{}))
}

//export Slice_float32_len
func Slice_float32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float32(handle))
}

//export Slice_float32_elem
func Slice_float32_elem(handle CGoHandle, _idx int) C.float {
	s := deptrFromHandle_Slice_float32(handle)
	return C.float(s[_idx])
}

//export Slice_float32_subslice
func Slice_float32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float32(&ss))
}

//export Slice_float32_set
func Slice_float32_set(handle CGoHandle, _idx int, _vl C.float) {
	s := deptrFromHandle_Slice_float32(handle)
	s[_idx] = float32(_vl)
}

//export Slice_float32_append
func Slice_float32_append(handle CGoHandle, _vl C.float) {
	s := ptrFromHandle_Slice_float32(handle)
	*s = append(*s, float32(_vl))
}

// Converters for implicit pointer handles for type: []float64
func ptrFromHandle_Slice_float64(h CGoHandle) *[]float64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float64")
	if p == nil {
		return nil
	}
	return p.(*[]float64)
}
func deptrFromHandle_Slice_float64(h CGoHandle) []float64 {
	p := ptrFromHandle_Slice_float64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float64", p))
}

// --- wrapping slice: []float64 ---
//
//export Slice_float64_CTor
func Slice_float64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float64(&[]float64{}))
}

//export Slice_float64_len
func Slice_float64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float64(handle))
}

//export Slice_float64_elem
func Slice_float64_elem(handle CGoHandle, _idx int) C.double {
	s := deptrFromHandle_Slice_float64(handle)
	return C.double(s[_idx])
}

//export Slice_float64_subslice
func Slice_float64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float64(&ss))
}

//export Slice_float64_set
func Slice_float64_set(handle CGoHandle, _idx int, _vl C.double) {
	s := deptrFromHandle_Slice_float64(handle)
	s[_idx] = float64(_vl)
}

//export Slice_float64_append
func Slice_float64_append(handle CGoHandle, _vl C.double) {
	s := ptrFromHandle_Slice_float64(handle)
	*s = append(*s, float64(_vl))
}

// Converters for implicit pointer handles for type: []int
func ptrFromHandle_Slice_int(h CGoHandle) *[]int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int")
	if p == nil {
		return nil
	}
	return p.(*[]int)
}
func deptrFromHandle_Slice_int(h CGoHandle) []int {
	p := ptrFromHandle_Slice_int(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int", p))
}

// --- wrapping slice: []int ---
//
//export Slice_int_CTor
func Slice_int_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int(&[]int{}))
}

//export Slice_int_len
func Slice_int_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int(handle))
}

//export Slice_int_elem
func Slice_int_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int(handle)
	return C.longlong(s[_idx])
}

//export Slice_int_subslice
func Slice_int_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int(&ss))
}

//export Slice_int_set
func Slice_int_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int(handle)
	s[_idx] = int(_vl)
}

//export Slice_int_append
func Slice_int_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int(handle)
	*s = append(*s, int(_vl))
}

// Converters for implicit pointer handles for type: []int16
func ptrFromHandle_Slice_int16(h CGoHandle) *[]int16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int16")
	if p == nil {
		return nil
	}
	return p.(*[]int16)
}
func deptrFromHandle_Slice_int16(h CGoHandle) []int16 {
	p := ptrFromHandle_Slice_int16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int16", p))
}

// --- wrapping slice: []int16 ---
//
//export Slice_int16_CTor
func Slice_int16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int16(&[]int16{}))
}

//export Slice_int16_len
func Slice_int16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int16(handle))
}

//export Slice_int16_elem
func Slice_int16_elem(handle CGoHandle, _idx int) C.short {
	s := deptrFromHandle_Slice_int16(handle)
	return C.short(s[_idx])
}

//export Slice_int16_subslice
func Slice_int16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int16(&ss))
}

//export Slice_int16_set
func Slice_int16_set(handle CGoHandle, _idx int, _vl C.short) {
	s := deptrFromHandle_Slice_int16(handle)
	s[_idx] = int16(_vl)
}

//export Slice_int16_append
func Slice_int16_append(handle CGoHandle, _vl C.short) {
	s := ptrFromHandle_Slice_int16(handle)
	*s = append(*s, int16(_vl))
}

// Converters for implicit pointer handles for type: []int32
func ptrFromHandle_Slice_int32(h CGoHandle) *[]int32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int32")
	if p == nil {
		return nil
	}
	return p.(*[]int32)
}
func deptrFromHandle_Slice_int32(h CGoHandle) []int32 {
	p := ptrFromHandle_Slice_int32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int32", p))
}

// --- wrapping slice: []int32 ---
//
//export Slice_int32_CTor
func Slice_int32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int32(&[]int32{}))
}

//export Slice_int32_len
func Slice_int32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int32(handle))
}

//export Slice_int32_elem
func Slice_int32_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_int32(handle)
	return C.long(s[_idx])
}

//export Slice_int32_subslice
func Slice_int32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int32(&ss))
}

//export Slice_int32_set
func Slice_int32_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_int32(handle)
	s[_idx] = int32(_vl)
}

//export Slice_int32_append
func Slice_int32_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_int32(handle)
	*s = append(*s, int32(_vl))
}

// Converters for implicit pointer handles for type: []int64
func ptrFromHandle_Slice_int64(h CGoHandle) *[]int64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int64")
	if p == nil {
		return nil
	}
	return p.(*[]int64)
}
func deptrFromHandle_Slice_int64(h CGoHandle) []int64 {
	p := ptrFromHandle_Slice_int64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int64", p))
}

// --- wrapping slice: []int64 ---
//
//export Slice_int64_CTor
func Slice_int64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int64(&[]int64{}))
}

//export Slice_int64_len
func Slice_int64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int64(handle))
}

//export Slice_int64_elem
func Slice_int64_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int64(handle)
	return C.longlong(s[_idx])
}

//export Slice_int64_subslice
func Slice_int64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int64(&ss))
}

//export Slice_int64_set
func Slice_int64_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int64(handle)
	s[_idx] = int64(_vl)
}

//export Slice_int64_append
func Slice_int64_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int64(handle)
	*s = append(*s, int64(_vl))
}

// Converters for implicit pointer handles for type: []int8
func ptrFromHandle_Slice_int8(h CGoHandle) *[]int8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int8")
	if p == nil {
		return nil
	}
	return p.(*[]int8)
}
func deptrFromHandle_Slice_int8(h CGoHandle) []int8 {
	p := ptrFromHandle_Slice_int8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int8", p))
}

// --- wrapping slice: []int8 ---
//
//export Slice_int8_CTor
func Slice_int8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int8(&[]int8{}))
}

//export Slice_int8_len
func Slice_int8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int8(handle))
}

//export Slice_int8_elem
func Slice_int8_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_int8(handle)
	return C.char(s[_idx])
}

//export Slice_int8_subslice
func Slice_int8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int8(&ss))
}

//export Slice_int8_set
func Slice_int8_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_int8(handle)
	s[_idx] = int8(_vl)
}

//export Slice_int8_append
func Slice_int8_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_int8(handle)
	*s = append(*s, int8(_vl))
}

// Converters for implicit pointer handles for type: []rune
func ptrFromHandle_Slice_rune(h CGoHandle) *[]rune {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]rune")
	if p == nil {
		return nil
	}
	return p.(*[]rune)
}
func deptrFromHandle_Slice_rune(h CGoHandle) []rune {
	p := ptrFromHandle_Slice_rune(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_rune(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]rune", p))
}

// --- wrapping slice: []rune ---
//
//export Slice_rune_CTor
func Slice_rune_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_rune(&[]rune{}))
}

//export Slice_rune_len
func Slice_rune_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_rune(handle))
}

//export Slice_rune_elem
func Slice_rune_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_rune(handle)
	return C.long(s[_idx])
}

//export Slice_rune_subslice
func Slice_rune_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_rune(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_rune(&ss))
}

//export Slice_rune_set
func Slice_rune_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_rune(handle)
	s[_idx] = rune(_vl)
}

//export Slice_rune_append
func Slice_rune_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_rune(handle)
	*s = append(*s, rune(_vl))
}

// Converters for implicit pointer handles for type: []string
func ptrFromHandle_Slice_string(h CGoHandle) *[]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]string")
	if p == nil {
		return nil
	}
	return p.(*[]string)
}
func deptrFromHandle_Slice_string(h CGoHandle) []string {
	p := ptrFromHandle_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]string", p))
}

// --- wrapping slice: []string ---
//
//export Slice_string_CTor
func Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_string(&[]string{}))
}

//export Slice_string_len
func Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_string(handle))
}

//export Slice_string_elem
func Slice_string_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_string(handle)
	return C.CString(s[_idx])
}

//export Slice_string_subslice
func Slice_string_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_string(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_string(&ss))
}

//export Slice_string_set
func Slice_string_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_string(handle)
	s[_idx] = C.GoString(_vl)
}

//export Slice_string_append
func Slice_string_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_string(handle)
	*s = append(*s, C.GoString(_vl))
}

// Converters for implicit pointer handles for type: []uint
func ptrFromHandle_Slice_uint(h CGoHandle) *[]uint {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint")
	if p == nil {
		return nil
	}
	return p.(*[]uint)
}
func deptrFromHandle_Slice_uint(h CGoHandle) []uint {
	p := ptrFromHandle_Slice_uint(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint", p))
}

// --- wrapping slice: []uint ---
//
//export Slice_uint_CTor
func Slice_uint_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint(&[]uint{}))
}

//export Slice_uint_len
func Slice_uint_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint(handle))
}

//export Slice_uint_elem
func Slice_uint_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint_subslice
func Slice_uint_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint(&ss))
}

//export Slice_uint_set
func Slice_uint_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint(handle)
	s[_idx] = uint(_vl)
}

//export Slice_uint_append
func Slice_uint_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint(handle)
	*s = append(*s, uint(_vl))
}

// Converters for implicit pointer handles for type: []uint16
func ptrFromHandle_Slice_uint16(h CGoHandle) *[]uint16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint16")
	if p == nil {
		return nil
	}
	return p.(*[]uint16)
}
func deptrFromHandle_Slice_uint16(h CGoHandle) []uint16 {
	p := ptrFromHandle_Slice_uint16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint16", p))
}

// --- wrapping slice: []uint16 ---
//
//export Slice_uint16_CTor
func Slice_uint16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint16(&[]uint16{}))
}

//export Slice_uint16_len
func Slice_uint16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint16(handle))
}

//export Slice_uint16_elem
func Slice_uint16_elem(handle CGoHandle, _idx int) C.ushort {
	s := deptrFromHandle_Slice_uint16(handle)
	return C.ushort(s[_idx])
}

//export Slice_uint16_subslice
func Slice_uint16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint16(&ss))
}

//export Slice_uint16_set
func Slice_uint16_set(handle CGoHandle, _idx int, _vl C.ushort) {
	s := deptrFromHandle_Slice_uint16(handle)
	s[_idx] = uint16(_vl)
}

//export Slice_uint16_append
func Slice_uint16_append(handle CGoHandle, _vl C.ushort) {
	s := ptrFromHandle_Slice_uint16(handle)
	*s = append(*s, uint16(_vl))
}

// Converters for implicit pointer handles for type: []uint32
func ptrFromHandle_Slice_uint32(h CGoHandle) *[]uint32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint32")
	if p == nil {
		return nil
	}
	return p.(*[]uint32)
}
func deptrFromHandle_Slice_uint32(h CGoHandle) []uint32 {
	p := ptrFromHandle_Slice_uint32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint32", p))
}

// --- wrapping slice: []uint32 ---
//
//export Slice_uint32_CTor
func Slice_uint32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint32(&[]uint32{}))
}

//export Slice_uint32_len
func Slice_uint32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint32(handle))
}

//export Slice_uint32_elem
func Slice_uint32_elem(handle CGoHandle, _idx int) C.ulong {
	s := deptrFromHandle_Slice_uint32(handle)
	return C.ulong(s[_idx])
}

//export Slice_uint32_subslice
func Slice_uint32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint32(&ss))
}

//export Slice_uint32_set
func Slice_uint32_set(handle CGoHandle, _idx int, _vl C.ulong) {
	s := deptrFromHandle_Slice_uint32(handle)
	s[_idx] = uint32(_vl)
}

//export Slice_uint32_append
func Slice_uint32_append(handle CGoHandle, _vl C.ulong) {
	s := ptrFromHandle_Slice_uint32(handle)
	*s = append(*s, uint32(_vl))
}

// Converters for implicit pointer handles for type: []uint64
func ptrFromHandle_Slice_uint64(h CGoHandle) *[]uint64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint64")
	if p == nil {
		return nil
	}
	return p.(*[]uint64)
}
func deptrFromHandle_Slice_uint64(h CGoHandle) []uint64 {
	p := ptrFromHandle_Slice_uint64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint64", p))
}

// --- wrapping slice: []uint64 ---
//
//export Slice_uint64_CTor
func Slice_uint64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint64(&[]uint64{}))
}

//export Slice_uint64_len
func Slice_uint64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint64(handle))
}

//export Slice_uint64_elem
func Slice_uint64_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint64(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint64_subslice
func Slice_uint64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint64(&ss))
}

//export Slice_uint64_set
func Slice_uint64_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint64(handle)
	s[_idx] = uint64(_vl)
}

//export Slice_uint64_append
func Slice_uint64_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint64(handle)
	*s = append(*s, uint64(_vl))
}

// Converters for implicit pointer handles for type: []uint8
func ptrFromHandle_Slice_uint8(h CGoHandle) *[]uint8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint8")
	if p == nil {
		return nil
	}
	return p.(*[]uint8)
}
func deptrFromHandle_Slice_uint8(h CGoHandle) []uint8 {
	p := ptrFromHandle_Slice_uint8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint8", p))
}

// --- wrapping slice: []uint8 ---
//
//export Slice_uint8_CTor
func Slice_uint8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint8(&[]uint8{}))
}

//export Slice_uint8_len
func Slice_uint8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint8(handle))
}

//export Slice_uint8_elem
func Slice_uint8_elem(handle CGoHandle, _idx int) C.uchar {
	s := deptrFromHandle_Slice_uint8(handle)
	return C.uchar(s[_idx])
}

//export Slice_uint8_subslice
func Slice_uint8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint8(&ss))
}

//export Slice_uint8_set
func Slice_uint8_set(handle CGoHandle, _idx int, _vl C.uchar) {
	s := deptrFromHandle_Slice_uint8(handle)
	s[_idx] = uint8(_vl)
}

//export Slice_uint8_append
func Slice_uint8_append(handle CGoHandle, _vl C.uchar) {
	s := ptrFromHandle_Slice_uint8(handle)
	*s = append(*s, uint8(_vl))
}

// ---- Package: game ---

// ---- Types ---

// Converters for pointer handles for type: *game.Character
func ptrFromHandle_Ptr_game_Character(h CGoHandle) *game.Character {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*game.Character")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(game.Character{})).(*game.Character)
}
func handleFromPtr_Ptr_game_Character(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*game.Character", p))
}

// Converters for pointer handles for type: *game.CharacterData
func ptrFromHandle_Ptr_game_CharacterData(h CGoHandle) *game.CharacterData {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*game.CharacterData")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(game.CharacterData{})).(*game.CharacterData)
}
func handleFromPtr_Ptr_game_CharacterData(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*game.CharacterData", p))
}

// Converters for pointer handles for type: *game.CharacterDescription
func ptrFromHandle_Ptr_game_CharacterDescription(h CGoHandle) *game.CharacterDescription {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*game.CharacterDescription")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(game.CharacterDescription{})).(*game.CharacterDescription)
}
func handleFromPtr_Ptr_game_CharacterDescription(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*game.CharacterDescription", p))
}

// Converters for pointer handles for type: *game.EffectDescription
func ptrFromHandle_Ptr_game_EffectDescription(h CGoHandle) *game.EffectDescription {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*game.EffectDescription")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(game.EffectDescription{})).(*game.EffectDescription)
}
func handleFromPtr_Ptr_game_EffectDescription(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*game.EffectDescription", p))
}

// Converters for pointer handles for type: *game.Skill
func ptrFromHandle_Ptr_game_Skill(h CGoHandle) *game.Skill {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*game.Skill")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(game.Skill{})).(*game.Skill)
}
func handleFromPtr_Ptr_game_Skill(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*game.Skill", p))
}

// Converters for pointer handles for type: *game.SkillData
func ptrFromHandle_Ptr_game_SkillData(h CGoHandle) *game.SkillData {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*game.SkillData")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(game.SkillData{})).(*game.SkillData)
}
func handleFromPtr_Ptr_game_SkillData(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*game.SkillData", p))
}

// Converters for pointer handles for type: *game.SkillDescription
func ptrFromHandle_Ptr_game_SkillDescription(h CGoHandle) *game.SkillDescription {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*game.SkillDescription")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(game.SkillDescription{})).(*game.SkillDescription)
}
func handleFromPtr_Ptr_game_SkillDescription(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*game.SkillDescription", p))
}

// Converters for pointer handles for type: *game.TurnState
func ptrFromHandle_Ptr_game_TurnState(h CGoHandle) *game.TurnState {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*game.TurnState")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(game.TurnState{})).(*game.TurnState)
}
func handleFromPtr_Ptr_game_TurnState(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*game.TurnState", p))
}

// Converters for implicit pointer handles for type: [4]*game.Skill
func ptrFromHandle_Array_4_Ptr_game_Skill(h CGoHandle) *[4]*game.Skill {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[4]*game.Skill")
	if p == nil {
		return nil
	}
	return p.(*[4]*game.Skill)
}
func deptrFromHandle_Array_4_Ptr_game_Skill(h CGoHandle) [4]*game.Skill {
	p := ptrFromHandle_Array_4_Ptr_game_Skill(h)
	return *p
}
func handleFromPtr_Array_4_Ptr_game_Skill(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[4]*game.Skill", p))
}

// --- wrapping slice: [4]*game.Skill ---
//
//export Array_4_Ptr_game_Skill_CTor
func Array_4_Ptr_game_Skill_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Array_4_Ptr_game_Skill(&[4]*game.Skill{}))
}

//export Array_4_Ptr_game_Skill_len
func Array_4_Ptr_game_Skill_len(handle CGoHandle) int {
	return len(deptrFromHandle_Array_4_Ptr_game_Skill(handle))
}

//export Array_4_Ptr_game_Skill_elem
func Array_4_Ptr_game_Skill_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Array_4_Ptr_game_Skill(handle)
	return handleFromPtr_Ptr_game_Skill(&(s[_idx]))
}

//export Array_4_Ptr_game_Skill_set
func Array_4_Ptr_game_Skill_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Array_4_Ptr_game_Skill(handle)
	s[_idx] = ptrFromHandle_Ptr_game_Skill(_vl)
}

// Converters for implicit pointer handles for type: [4]*game.SkillData
func ptrFromHandle_Array_4_Ptr_game_SkillData(h CGoHandle) *[4]*game.SkillData {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[4]*game.SkillData")
	if p == nil {
		return nil
	}
	return p.(*[4]*game.SkillData)
}
func deptrFromHandle_Array_4_Ptr_game_SkillData(h CGoHandle) [4]*game.SkillData {
	p := ptrFromHandle_Array_4_Ptr_game_SkillData(h)
	return *p
}
func handleFromPtr_Array_4_Ptr_game_SkillData(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[4]*game.SkillData", p))
}

// --- wrapping slice: [4]*game.SkillData ---
//
//export Array_4_Ptr_game_SkillData_CTor
func Array_4_Ptr_game_SkillData_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Array_4_Ptr_game_SkillData(&[4]*game.SkillData{}))
}

//export Array_4_Ptr_game_SkillData_len
func Array_4_Ptr_game_SkillData_len(handle CGoHandle) int {
	return len(deptrFromHandle_Array_4_Ptr_game_SkillData(handle))
}

//export Array_4_Ptr_game_SkillData_elem
func Array_4_Ptr_game_SkillData_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Array_4_Ptr_game_SkillData(handle)
	return handleFromPtr_Ptr_game_SkillData(&(s[_idx]))
}

//export Array_4_Ptr_game_SkillData_set
func Array_4_Ptr_game_SkillData_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Array_4_Ptr_game_SkillData(handle)
	s[_idx] = ptrFromHandle_Ptr_game_SkillData(_vl)
}

// Converters for implicit pointer handles for type: []game.Colour
func ptrFromHandle_Slice_game_Colour(h CGoHandle) *[]game.Colour {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]game.Colour")
	if p == nil {
		return nil
	}
	return p.(*[]game.Colour)
}
func deptrFromHandle_Slice_game_Colour(h CGoHandle) []game.Colour {
	p := ptrFromHandle_Slice_game_Colour(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_game_Colour(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]game.Colour", p))
}

// --- wrapping slice: []game.Colour ---
//
//export Slice_game_Colour_CTor
func Slice_game_Colour_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_game_Colour(&[]game.Colour{}))
}

//export Slice_game_Colour_len
func Slice_game_Colour_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_game_Colour(handle))
}

//export Slice_game_Colour_elem
func Slice_game_Colour_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_game_Colour(handle)
	return C.longlong(int(s[_idx]))
}

//export Slice_game_Colour_subslice
func Slice_game_Colour_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_game_Colour(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_game_Colour(&ss))
}

//export Slice_game_Colour_set
func Slice_game_Colour_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_game_Colour(handle)
	s[_idx] = game.Colour(int(_vl))
}

//export Slice_game_Colour_append
func Slice_game_Colour_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_game_Colour(handle)
	*s = append(*s, game.Colour(int(_vl)))
}

// Converters for implicit pointer handles for type: []game.Effect
func ptrFromHandle_Slice_game_Effect(h CGoHandle) *[]game.Effect {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]game.Effect")
	if p == nil {
		return nil
	}
	return p.(*[]game.Effect)
}
func deptrFromHandle_Slice_game_Effect(h CGoHandle) []game.Effect {
	p := ptrFromHandle_Slice_game_Effect(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_game_Effect(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]game.Effect", p))
}

// --- wrapping slice: []game.Effect ---
//
//export Slice_game_Effect_CTor
func Slice_game_Effect_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_game_Effect(&[]game.Effect{}))
}

//export Slice_game_Effect_len
func Slice_game_Effect_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_game_Effect(handle))
}

//export Slice_game_Effect_elem
func Slice_game_Effect_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_game_Effect(handle)
	return handleFromPtr_game_Effect(&(s[_idx]))
}

//export Slice_game_Effect_subslice
func Slice_game_Effect_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_game_Effect(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_game_Effect(&ss))
}

//export Slice_game_Effect_set
func Slice_game_Effect_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_game_Effect(handle)
	s[_idx] = ptrFromHandle_game_Effect(_vl)
}

//export Slice_game_Effect_append
func Slice_game_Effect_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_game_Effect(handle)
	*s = append(*s, ptrFromHandle_game_Effect(_vl))
}

// Converters for non-pointer handles for type: game.Character
func ptrFromHandle_game_Character(h CGoHandle) *game.Character {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "game.Character")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(game.Character{})).(*game.Character)
}
func handleFromPtr_game_Character(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("game.Character", p))
}

// Converters for non-pointer handles for type: game.CharacterData
func ptrFromHandle_game_CharacterData(h CGoHandle) *game.CharacterData {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "game.CharacterData")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(game.CharacterData{})).(*game.CharacterData)
}
func handleFromPtr_game_CharacterData(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("game.CharacterData", p))
}

// Converters for non-pointer handles for type: game.CharacterDescription
func ptrFromHandle_game_CharacterDescription(h CGoHandle) *game.CharacterDescription {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "game.CharacterDescription")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(game.CharacterDescription{})).(*game.CharacterDescription)
}
func handleFromPtr_game_CharacterDescription(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("game.CharacterDescription", p))
}

// Converters for pointer handles for type: game.ControlHandler
func ptrFromHandle_game_ControlHandler(h CGoHandle) game.ControlHandler {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "game.ControlHandler")
	if p == nil {
		return nil
	}
	return p.(game.ControlHandler)
}
func handleFromPtr_game_ControlHandler(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("game.ControlHandler", p))
}

// Converters for pointer handles for type: game.DealtDamageModifier
func ptrFromHandle_game_DealtDamageModifier(h CGoHandle) game.DealtDamageModifier {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "game.DealtDamageModifier")
	if p == nil {
		return nil
	}
	return p.(game.DealtDamageModifier)
}
func handleFromPtr_game_DealtDamageModifier(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("game.DealtDamageModifier", p))
}

// Converters for pointer handles for type: game.DefenceModifier
func ptrFromHandle_game_DefenceModifier(h CGoHandle) game.DefenceModifier {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "game.DefenceModifier")
	if p == nil {
		return nil
	}
	return p.(game.DefenceModifier)
}
func handleFromPtr_game_DefenceModifier(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("game.DefenceModifier", p))
}

// Converters for pointer handles for type: game.Effect
func ptrFromHandle_game_Effect(h CGoHandle) game.Effect {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "game.Effect")
	if p == nil {
		return nil
	}
	return p.(game.Effect)
}
func handleFromPtr_game_Effect(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("game.Effect", p))
}

// Converters for non-pointer handles for type: game.EffectDescription
func ptrFromHandle_game_EffectDescription(h CGoHandle) *game.EffectDescription {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "game.EffectDescription")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(game.EffectDescription{})).(*game.EffectDescription)
}
func handleFromPtr_game_EffectDescription(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("game.EffectDescription", p))
}

// Converters for pointer handles for type: game.EffectFilter
func ptrFromHandle_game_EffectFilter(h CGoHandle) game.EffectFilter {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "game.EffectFilter")
	if p == nil {
		return nil
	}
	return p.(game.EffectFilter)
}
func handleFromPtr_game_EffectFilter(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("game.EffectFilter", p))
}

// Converters for pointer handles for type: game.Expirable
func ptrFromHandle_game_Expirable(h CGoHandle) game.Expirable {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "game.Expirable")
	if p == nil {
		return nil
	}
	return p.(game.Expirable)
}
func handleFromPtr_game_Expirable(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("game.Expirable", p))
}

// Converters for pointer handles for type: game.HealFilter
func ptrFromHandle_game_HealFilter(h CGoHandle) game.HealFilter {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "game.HealFilter")
	if p == nil {
		return nil
	}
	return p.(game.HealFilter)
}
func handleFromPtr_game_HealFilter(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("game.HealFilter", p))
}

// Converters for non-pointer handles for type: game.Skill
func ptrFromHandle_game_Skill(h CGoHandle) *game.Skill {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "game.Skill")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(game.Skill{})).(*game.Skill)
}
func handleFromPtr_game_Skill(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("game.Skill", p))
}

// Converters for pointer handles for type: game.SkillAvailabilityFilter
func ptrFromHandle_game_SkillAvailabilityFilter(h CGoHandle) game.SkillAvailabilityFilter {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "game.SkillAvailabilityFilter")
	if p == nil {
		return nil
	}
	return p.(game.SkillAvailabilityFilter)
}
func handleFromPtr_game_SkillAvailabilityFilter(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("game.SkillAvailabilityFilter", p))
}

// Converters for non-pointer handles for type: game.SkillData
func ptrFromHandle_game_SkillData(h CGoHandle) *game.SkillData {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "game.SkillData")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(game.SkillData{})).(*game.SkillData)
}
func handleFromPtr_game_SkillData(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("game.SkillData", p))
}

// Converters for non-pointer handles for type: game.SkillDescription
func ptrFromHandle_game_SkillDescription(h CGoHandle) *game.SkillDescription {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "game.SkillDescription")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(game.SkillDescription{})).(*game.SkillDescription)
}
func handleFromPtr_game_SkillDescription(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("game.SkillDescription", p))
}

// Converters for pointer handles for type: game.SkillUnlockTurnModifier
func ptrFromHandle_game_SkillUnlockTurnModifier(h CGoHandle) game.SkillUnlockTurnModifier {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "game.SkillUnlockTurnModifier")
	if p == nil {
		return nil
	}
	return p.(game.SkillUnlockTurnModifier)
}
func handleFromPtr_game_SkillUnlockTurnModifier(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("game.SkillUnlockTurnModifier", p))
}

// Converters for pointer handles for type: game.SkillsPerTurnHandler
func ptrFromHandle_game_SkillsPerTurnHandler(h CGoHandle) game.SkillsPerTurnHandler {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "game.SkillsPerTurnHandler")
	if p == nil {
		return nil
	}
	return p.(game.SkillsPerTurnHandler)
}
func handleFromPtr_game_SkillsPerTurnHandler(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("game.SkillsPerTurnHandler", p))
}

// Converters for pointer handles for type: game.TakenDamageModifier
func ptrFromHandle_game_TakenDamageModifier(h CGoHandle) game.TakenDamageModifier {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "game.TakenDamageModifier")
	if p == nil {
		return nil
	}
	return p.(game.TakenDamageModifier)
}
func handleFromPtr_game_TakenDamageModifier(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("game.TakenDamageModifier", p))
}

// Converters for pointer handles for type: game.TurnEndHandler
func ptrFromHandle_game_TurnEndHandler(h CGoHandle) game.TurnEndHandler {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "game.TurnEndHandler")
	if p == nil {
		return nil
	}
	return p.(game.TurnEndHandler)
}
func handleFromPtr_game_TurnEndHandler(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("game.TurnEndHandler", p))
}

// Converters for non-pointer handles for type: game.TurnState
func ptrFromHandle_game_TurnState(h CGoHandle) *game.TurnState {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "game.TurnState")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(game.TurnState{})).(*game.TurnState)
}
func handleFromPtr_game_TurnState(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("game.TurnState", p))
}

// Converters for implicit pointer handles for type: map[game.Colour]int
func ptrFromHandle_Map_game_Colour_int(h CGoHandle) *map[game.Colour]int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[game.Colour]int")
	if p == nil {
		return nil
	}
	return p.(*map[game.Colour]int)
}
func deptrFromHandle_Map_game_Colour_int(h CGoHandle) map[game.Colour]int {
	p := ptrFromHandle_Map_game_Colour_int(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_game_Colour_int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[game.Colour]int", p))
}

// --- wrapping map: map[game.Colour]int ---
//
//export Map_game_Colour_int_CTor
func Map_game_Colour_int_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_game_Colour_int(&map[game.Colour]int{}))
}

//export Map_game_Colour_int_len
func Map_game_Colour_int_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_game_Colour_int(handle))
}

//export Map_game_Colour_int_elem
func Map_game_Colour_int_elem(handle CGoHandle, _ky C.longlong) C.longlong {
	s := deptrFromHandle_Map_game_Colour_int(handle)
	v, ok := s[game.Colour(int(_ky))]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return C.longlong(v)
}

//export Map_game_Colour_int_contains
func Map_game_Colour_int_contains(handle CGoHandle, _ky C.longlong) C.char {
	s := deptrFromHandle_Map_game_Colour_int(handle)
	_, ok := s[game.Colour(int(_ky))]
	return boolGoToPy(ok)
}

//export Map_game_Colour_int_set
func Map_game_Colour_int_set(handle CGoHandle, _ky C.longlong, _vl C.longlong) {
	s := deptrFromHandle_Map_game_Colour_int(handle)
	s[game.Colour(int(_ky))] = int(_vl)
}

//export Map_game_Colour_int_delete
func Map_game_Colour_int_delete(handle CGoHandle, _ky C.longlong) {
	s := deptrFromHandle_Map_game_Colour_int(handle)
	delete(s, game.Colour(int(_ky)))
}

//export Map_game_Colour_int_keys
func Map_game_Colour_int_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_game_Colour_int(handle)
	kys := make([]game.Colour, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_game_Colour(&kys)
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

//export game_DealtDamageModifier_ModifyDealtDamage
func game_DealtDamageModifier_ModifyDealtDamage(_handle CGoHandle, dmg C.longlong, colour C.longlong) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "game.DealtDamageModifier")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(vifc.(game.DealtDamageModifier).ModifyDealtDamage(int(dmg), game.Colour(int(colour))))

}

//export game_EffectFilter_IsEffectAllowed
func game_EffectFilter_IsEffectAllowed(_handle CGoHandle, e CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "game.EffectFilter")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(vifc.(game.EffectFilter).IsEffectAllowed(ptrFromHandle_game_Effect(e)))

}

//export game_HealFilter_IsHealAllowed
func game_HealFilter_IsHealAllowed(_handle CGoHandle, heal C.longlong) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "game.HealFilter")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(vifc.(game.HealFilter).IsHealAllowed(int(heal)))

}

//export game_SkillUnlockTurnModifier_ModifySkillUnlockTurn
func game_SkillUnlockTurnModifier_ModifySkillUnlockTurn(_handle CGoHandle, s CGoHandle, unlockTurn C.longlong) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "game.SkillUnlockTurnModifier")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(vifc.(game.SkillUnlockTurnModifier).ModifySkillUnlockTurn(ptrFromHandle_Ptr_game_Skill(s), int(unlockTurn)))

}

//export game_SkillAvailabilityFilter_IsSkillAvailable
func game_SkillAvailabilityFilter_IsSkillAvailable(_handle CGoHandle, s CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "game.SkillAvailabilityFilter")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(vifc.(game.SkillAvailabilityFilter).IsSkillAvailable(ptrFromHandle_Ptr_game_Skill(s)))

}

//export game_SkillsPerTurnHandler_SkillsPerTurn
func game_SkillsPerTurnHandler_SkillsPerTurn(_handle CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "game.SkillsPerTurnHandler")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(vifc.(game.SkillsPerTurnHandler).SkillsPerTurn())

}

//export game_TakenDamageModifier_ModifyTakenDamage
func game_TakenDamageModifier_ModifyTakenDamage(_handle CGoHandle, dmg C.longlong, colour C.longlong) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "game.TakenDamageModifier")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(vifc.(game.TakenDamageModifier).ModifyTakenDamage(int(dmg), game.Colour(int(colour))))

}

//export game_TurnEndHandler_OnTurnEnd
func game_TurnEndHandler_OnTurnEnd(_handle CGoHandle, c CGoHandle, opp CGoHandle, turnState CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "game.TurnEndHandler")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(game.TurnEndHandler).OnTurnEnd(ptrFromHandle_Ptr_game_Character(c), ptrFromHandle_Ptr_game_Character(opp), *ptrFromHandle_game_TurnState(turnState))
	} else {
		vifc.(game.TurnEndHandler).OnTurnEnd(ptrFromHandle_Ptr_game_Character(c), ptrFromHandle_Ptr_game_Character(opp), *ptrFromHandle_game_TurnState(turnState))
	}
}

//export game_ControlHandler_HasTakenControl
func game_ControlHandler_HasTakenControl(_handle CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "game.ControlHandler")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(vifc.(game.ControlHandler).HasTakenControl())

}

//export game_DefenceModifier_ModifyDefences
func game_DefenceModifier_ModifyDefences(_handle CGoHandle, mydef CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "game.DefenceModifier")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(game.DefenceModifier).ModifyDefences(deptrFromHandle_Map_game_Colour_int(mydef))
	} else {
		vifc.(game.DefenceModifier).ModifyDefences(deptrFromHandle_Map_game_Colour_int(mydef))
	}
}

//export game_Effect_Clone
func game_Effect_Clone(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "game.Effect")
	if __err != nil {
		return handleFromPtr_game_Effect(nil)
	}
	return handleFromPtr_game_Effect(vifc.(game.Effect).Clone())

}

//export game_Effect_Desc
func game_Effect_Desc(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "game.Effect")
	if __err != nil {
		return handleFromPtr_game_EffectDescription(nil)
	}
	cret := vifc.(game.Effect).Desc()

	return handleFromPtr_game_EffectDescription(&cret)
}

//export game_Expirable_HasExpired
func game_Expirable_HasExpired(_handle CGoHandle, turnState CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "game.Expirable")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(vifc.(game.Expirable).HasExpired(*ptrFromHandle_game_TurnState(turnState)))

}

// ---- Structs ---

// --- wrapping struct: game.EffectDescription ---
//
//export game_EffectDescription_CTor
func game_EffectDescription_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_game_EffectDescription(&game.EffectDescription{}))
}

//export game_EffectDescription_Name_Get
func game_EffectDescription_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_game_EffectDescription(handle)
	return C.CString(op.Name)
}

//export game_EffectDescription_Name_Set
func game_EffectDescription_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_game_EffectDescription(handle)
	op.Name = C.GoString(val)
}

//export game_EffectDescription_Type_Get
func game_EffectDescription_Type_Get(handle CGoHandle) C.uchar {
	op := ptrFromHandle_game_EffectDescription(handle)
	return C.uchar(uint8(op.Type))
}

//export game_EffectDescription_Type_Set
func game_EffectDescription_Type_Set(handle CGoHandle, val C.uchar) {
	op := ptrFromHandle_game_EffectDescription(handle)
	op.Type = game.EffectType(uint8(val))
}

// --- wrapping struct: game.Skill ---
//
//export game_Skill_CTor
func game_Skill_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_game_Skill(&game.Skill{}))
}

//export game_Skill_Desc
func game_Skill_Desc(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*game.Skill")
	if __err != nil {
		return handleFromPtr_game_SkillDescription(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(game.Skill{})).(*game.Skill).Desc()

	return handleFromPtr_game_SkillDescription(&cret)
}

//export game_Skill_Cooldown
func game_Skill_Cooldown(_handle CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*game.Skill")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(gopyh.Embed(vifc, reflect.TypeOf(game.Skill{})).(*game.Skill).Cooldown())

}

//export game_Skill_UnlockTurn
func game_Skill_UnlockTurn(_handle CGoHandle, c CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*game.Skill")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(gopyh.Embed(vifc, reflect.TypeOf(game.Skill{})).(*game.Skill).UnlockTurn(ptrFromHandle_Ptr_game_Character(c)))

}

//export game_Skill_IsAvailable
func game_Skill_IsAvailable(_handle CGoHandle, c CGoHandle, opp CGoHandle, turnState CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*game.Skill")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(gopyh.Embed(vifc, reflect.TypeOf(game.Skill{})).(*game.Skill).IsAvailable(ptrFromHandle_Ptr_game_Character(c), ptrFromHandle_Ptr_game_Character(opp), *ptrFromHandle_game_TurnState(turnState)))

}

//export game_Skill_Use
func game_Skill_Use(_handle CGoHandle, c CGoHandle, opp CGoHandle, turnState CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*game.Skill")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(game.Skill{})).(*game.Skill).Use(ptrFromHandle_Ptr_game_Character(c), ptrFromHandle_Ptr_game_Character(opp), *ptrFromHandle_game_TurnState(turnState))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export game_Skill_IsAppropriate
func game_Skill_IsAppropriate(_handle CGoHandle, c CGoHandle, opp CGoHandle, turnState CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*game.Skill")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(gopyh.Embed(vifc, reflect.TypeOf(game.Skill{})).(*game.Skill).IsAppropriate(ptrFromHandle_Ptr_game_Character(c), ptrFromHandle_Ptr_game_Character(opp), *ptrFromHandle_game_TurnState(turnState)))

}

// --- wrapping struct: game.SkillData ---
//
//export game_SkillData_CTor
func game_SkillData_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_game_SkillData(&game.SkillData{}))
}

//export game_SkillData_Desc_Get
func game_SkillData_Desc_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_game_SkillData(handle)
	return handleFromPtr_game_SkillDescription(&op.Desc)
}

//export game_SkillData_Desc_Set
func game_SkillData_Desc_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_game_SkillData(handle)
	op.Desc = *ptrFromHandle_game_SkillDescription(val)
}

//export game_SkillData_Cooldown_Get
func game_SkillData_Cooldown_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_game_SkillData(handle)
	return C.longlong(op.Cooldown)
}

//export game_SkillData_Cooldown_Set
func game_SkillData_Cooldown_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_game_SkillData(handle)
	op.Cooldown = int(val)
}

//export game_SkillData_UnlockTurn_Get
func game_SkillData_UnlockTurn_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_game_SkillData(handle)
	return C.longlong(op.UnlockTurn)
}

//export game_SkillData_UnlockTurn_Set
func game_SkillData_UnlockTurn_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_game_SkillData(handle)
	op.UnlockTurn = int(val)
}

// --- wrapping struct: game.SkillDescription ---
//
//export game_SkillDescription_CTor
func game_SkillDescription_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_game_SkillDescription(&game.SkillDescription{}))
}

//export game_SkillDescription_Name_Get
func game_SkillDescription_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_game_SkillDescription(handle)
	return C.CString(op.Name)
}

//export game_SkillDescription_Name_Set
func game_SkillDescription_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_game_SkillDescription(handle)
	op.Name = C.GoString(val)
}

//export game_SkillDescription_Colour_Get
func game_SkillDescription_Colour_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_game_SkillDescription(handle)
	return C.longlong(int(op.Colour))
}

//export game_SkillDescription_Colour_Set
func game_SkillDescription_Colour_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_game_SkillDescription(handle)
	op.Colour = game.Colour(int(val))
}

//export game_SkillDescription_IsUltimate_Get
func game_SkillDescription_IsUltimate_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_game_SkillDescription(handle)
	return boolGoToPy(op.IsUltimate)
}

//export game_SkillDescription_IsUltimate_Set
func game_SkillDescription_IsUltimate_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_game_SkillDescription(handle)
	op.IsUltimate = boolPyToGo(val)
}

// --- wrapping struct: game.TurnState ---
//
//export game_TurnState_CTor
func game_TurnState_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_game_TurnState(&game.TurnState{}))
}

//export game_TurnState_TurnNum_Get
func game_TurnState_TurnNum_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_game_TurnState(handle)
	return C.longlong(op.TurnNum)
}

//export game_TurnState_TurnNum_Set
func game_TurnState_TurnNum_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_game_TurnState(handle)
	op.TurnNum = int(val)
}

//export game_TurnState_IsGoingFirst_Get
func game_TurnState_IsGoingFirst_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_game_TurnState(handle)
	return boolGoToPy(op.IsGoingFirst)
}

//export game_TurnState_IsGoingFirst_Set
func game_TurnState_IsGoingFirst_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_game_TurnState(handle)
	op.IsGoingFirst = boolPyToGo(val)
}

//export game_TurnState_IsTurnEnd_Get
func game_TurnState_IsTurnEnd_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_game_TurnState(handle)
	return boolGoToPy(op.IsTurnEnd)
}

//export game_TurnState_IsTurnEnd_Set
func game_TurnState_IsTurnEnd_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_game_TurnState(handle)
	op.IsTurnEnd = boolPyToGo(val)
}

//export game_TurnState_WithGoingFirst
func game_TurnState_WithGoingFirst(_handle CGoHandle, isGoingFirst C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*game.TurnState")
	if __err != nil {
		return handleFromPtr_game_TurnState(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(game.TurnState{})).(*game.TurnState).WithGoingFirst(boolPyToGo(isGoingFirst))

	return handleFromPtr_game_TurnState(&cret)
}

//export game_TurnState_WithTurnEnd
func game_TurnState_WithTurnEnd(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*game.TurnState")
	if __err != nil {
		return handleFromPtr_game_TurnState(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(game.TurnState{})).(*game.TurnState).WithTurnEnd()

	return handleFromPtr_game_TurnState(&cret)
}

//export game_TurnState_IsAfter
func game_TurnState_IsAfter(_handle CGoHandle, other CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*game.TurnState")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(gopyh.Embed(vifc, reflect.TypeOf(game.TurnState{})).(*game.TurnState).IsAfter(*ptrFromHandle_game_TurnState(other)))

}

//export game_TurnState_AddTurns
func game_TurnState_AddTurns(_handle CGoHandle, turns C.longlong, isOpponentsTurn C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*game.TurnState")
	if __err != nil {
		return handleFromPtr_game_TurnState(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(game.TurnState{})).(*game.TurnState).AddTurns(int(turns), boolPyToGo(isOpponentsTurn))

	return handleFromPtr_game_TurnState(&cret)
}

//export game_TurnState_Next
func game_TurnState_Next(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*game.TurnState")
	if __err != nil {
		return handleFromPtr_game_TurnState(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(game.TurnState{})).(*game.TurnState).Next()

	return handleFromPtr_game_TurnState(&cret)
}

// --- wrapping struct: game.Character ---
//
//export game_Character_CTor
func game_Character_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_game_Character(&game.Character{}))
}

//export game_Character_Desc
func game_Character_Desc(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*game.Character")
	if __err != nil {
		return handleFromPtr_game_CharacterDescription(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(game.Character{})).(*game.Character).Desc()

	return handleFromPtr_game_CharacterDescription(&cret)
}

//export game_Character_HP
func game_Character_HP(_handle CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*game.Character")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(gopyh.Embed(vifc, reflect.TypeOf(game.Character{})).(*game.Character).HP())

}

//export game_Character_MaxHP
func game_Character_MaxHP(_handle CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*game.Character")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(gopyh.Embed(vifc, reflect.TypeOf(game.Character{})).(*game.Character).MaxHP())

}

//export game_Character_Defences
func game_Character_Defences(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*game.Character")
	if __err != nil {
		return handleFromPtr_Map_game_Colour_int(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(game.Character{})).(*game.Character).Defences()

	return handleFromPtr_Map_game_Colour_int(&cret)
}

//export game_Character_Effects
func game_Character_Effects(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*game.Character")
	if __err != nil {
		return handleFromPtr_Slice_game_Effect(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(game.Character{})).(*game.Character).Effects()

	return handleFromPtr_Slice_game_Effect(&cret)
}

//export game_Character_Skills
func game_Character_Skills(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*game.Character")
	if __err != nil {
		return handleFromPtr_Array_4_Ptr_game_Skill(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(game.Character{})).(*game.Character).Skills()

	return handleFromPtr_Array_4_Ptr_game_Skill(&cret)
}

//export game_Character_LastUsedSkill
func game_Character_LastUsedSkill(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*game.Character")
	if __err != nil {
		return handleFromPtr_Ptr_game_Skill(nil)
	}
	return handleFromPtr_Ptr_game_Skill(gopyh.Embed(vifc, reflect.TypeOf(game.Character{})).(*game.Character).LastUsedSkill())

}

//export game_Character_IsControlledByOpp
func game_Character_IsControlledByOpp(_handle CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*game.Character")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(gopyh.Embed(vifc, reflect.TypeOf(game.Character{})).(*game.Character).IsControlledByOpp())

}

//export game_Character_SkillsPerTurn
func game_Character_SkillsPerTurn(_handle CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*game.Character")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(gopyh.Embed(vifc, reflect.TypeOf(game.Character{})).(*game.Character).SkillsPerTurn())

}

//export game_Character_SetMaxHP
func game_Character_SetMaxHP(_handle CGoHandle, maxHP C.longlong, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*game.Character")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(game.Character{})).(*game.Character).SetMaxHP(int(maxHP))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(game.Character{})).(*game.Character).SetMaxHP(int(maxHP))
	}
}

//export game_Character_AddEffect
func game_Character_AddEffect(_handle CGoHandle, eff CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*game.Character")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(game.Character{})).(*game.Character).AddEffect(ptrFromHandle_game_Effect(eff))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(game.Character{})).(*game.Character).AddEffect(ptrFromHandle_game_Effect(eff))
	}
}

//export game_Character_Damage
func game_Character_Damage(_handle CGoHandle, opp CGoHandle, dmg C.longlong, colour C.longlong) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*game.Character")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(gopyh.Embed(vifc, reflect.TypeOf(game.Character{})).(*game.Character).Damage(ptrFromHandle_Ptr_game_Character(opp), int(dmg), game.Colour(int(colour))))

}

//export game_Character_Kill
func game_Character_Kill(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*game.Character")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(game.Character{})).(*game.Character).Kill()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(game.Character{})).(*game.Character).Kill()
	}
}

//export game_Character_CanHeal
func game_Character_CanHeal(_handle CGoHandle, heal C.longlong) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*game.Character")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(gopyh.Embed(vifc, reflect.TypeOf(game.Character{})).(*game.Character).CanHeal(int(heal)))

}

//export game_Character_Heal
func game_Character_Heal(_handle CGoHandle, heal C.longlong) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*game.Character")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(gopyh.Embed(vifc, reflect.TypeOf(game.Character{})).(*game.Character).Heal(int(heal)))

}

//export game_Character_OnTurnEnd
func game_Character_OnTurnEnd(_handle CGoHandle, opp CGoHandle, turnState CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*game.Character")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(game.Character{})).(*game.Character).OnTurnEnd(ptrFromHandle_Ptr_game_Character(opp), *ptrFromHandle_game_TurnState(turnState))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(game.Character{})).(*game.Character).OnTurnEnd(ptrFromHandle_Ptr_game_Character(opp), *ptrFromHandle_game_TurnState(turnState))
	}
}

//export game_Character_Clone
func game_Character_Clone(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*game.Character")
	if __err != nil {
		return handleFromPtr_Ptr_game_Character(nil)
	}
	return handleFromPtr_Ptr_game_Character(gopyh.Embed(vifc, reflect.TypeOf(game.Character{})).(*game.Character).Clone())

}

//export game_Character_CloneWithSkill
func game_Character_CloneWithSkill(_handle CGoHandle, i C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*game.Character")
	if __err != nil {
		return handleFromPtr_Ptr_game_Character(nil)
	}
	return handleFromPtr_Ptr_game_Character(gopyh.Embed(vifc, reflect.TypeOf(game.Character{})).(*game.Character).CloneWithSkill(int(i)))

}

//export game_Character_CloneWithoutSkills
func game_Character_CloneWithoutSkills(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*game.Character")
	if __err != nil {
		return handleFromPtr_Ptr_game_Character(nil)
	}
	return handleFromPtr_Ptr_game_Character(gopyh.Embed(vifc, reflect.TypeOf(game.Character{})).(*game.Character).CloneWithoutSkills())

}

// --- wrapping struct: game.CharacterData ---
//
//export game_CharacterData_CTor
func game_CharacterData_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_game_CharacterData(&game.CharacterData{}))
}

//export game_CharacterData_SkillData_Get
func game_CharacterData_SkillData_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_game_CharacterData(handle)
	return handleFromPtr_Array_4_Ptr_game_SkillData(&op.SkillData)
}

//export game_CharacterData_Desc_Get
func game_CharacterData_Desc_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_game_CharacterData(handle)
	return handleFromPtr_game_CharacterDescription(&op.Desc)
}

//export game_CharacterData_Desc_Set
func game_CharacterData_Desc_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_game_CharacterData(handle)
	op.Desc = *ptrFromHandle_game_CharacterDescription(val)
}

//export game_CharacterData_DefaultHP_Get
func game_CharacterData_DefaultHP_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_game_CharacterData(handle)
	return C.longlong(op.DefaultHP)
}

//export game_CharacterData_DefaultHP_Set
func game_CharacterData_DefaultHP_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_game_CharacterData(handle)
	op.DefaultHP = int(val)
}

//export game_CharacterData_Defences_Get
func game_CharacterData_Defences_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_game_CharacterData(handle)
	return handleFromPtr_Map_game_Colour_int(&op.Defences)
}

//export game_CharacterData_Defences_Set
func game_CharacterData_Defences_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_game_CharacterData(handle)
	op.Defences = deptrFromHandle_Map_game_Colour_int(val)
}

// --- wrapping struct: game.CharacterDescription ---
//
//export game_CharacterDescription_CTor
func game_CharacterDescription_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_game_CharacterDescription(&game.CharacterDescription{}))
}

//export game_CharacterDescription_Name_Get
func game_CharacterDescription_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_game_CharacterDescription(handle)
	return C.CString(op.Name)
}

//export game_CharacterDescription_Name_Set
func game_CharacterDescription_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_game_CharacterDescription(handle)
	op.Name = C.GoString(val)
}

//export game_CharacterDescription_Number_Get
func game_CharacterDescription_Number_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_game_CharacterDescription(handle)
	return C.longlong(op.Number)
}

//export game_CharacterDescription_Number_Set
func game_CharacterDescription_Number_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_game_CharacterDescription(handle)
	op.Number = int(val)
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export game_NewSkill
func game_NewSkill(data CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_game_Skill(game.NewSkill(ptrFromHandle_Ptr_game_SkillData(data)))

}

//export game_StartTurnState
func game_StartTurnState() CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := game.StartTurnState()

	return handleFromPtr_game_TurnState(&cret)
}

//export game_NewTurnState
func game_NewTurnState(turnNum C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := game.NewTurnState(int(turnNum))

	return handleFromPtr_game_TurnState(&cret)
}

//export game_NewCharacter
func game_NewCharacter(data CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_game_Character(game.NewCharacter(ptrFromHandle_Ptr_game_CharacterData(data)))

}

// ---- Functions ---

// ---- Package: characters ---

// ---- Types ---

// ---- Global Variables: can only use functions to access ---
//
//export characters_Hmm
func characters_Hmm() C.longlong {
	return C.longlong(characters.Hmm)
}

//export characters_Set_Hmm
func characters_Set_Hmm(val C.longlong) {
	characters.Hmm = int(val)
}

// ---- Interfaces ---

// ---- Structs ---

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

// ---- Functions ---

// ---- Package: euphoria ---

// ---- Types ---

// Converters for pointer handles for type: *euphoria.EffectEuphoricHeal
func ptrFromHandle_Ptr_euphoria_EffectEuphoricHeal(h CGoHandle) *euphoria.EffectEuphoricHeal {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*euphoria.EffectEuphoricHeal")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(euphoria.EffectEuphoricHeal{})).(*euphoria.EffectEuphoricHeal)
}
func handleFromPtr_Ptr_euphoria_EffectEuphoricHeal(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*euphoria.EffectEuphoricHeal", p))
}

// Converters for pointer handles for type: *euphoria.EffectEuphoricSource
func ptrFromHandle_Ptr_euphoria_EffectEuphoricSource(h CGoHandle) *euphoria.EffectEuphoricSource {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*euphoria.EffectEuphoricSource")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(euphoria.EffectEuphoricSource{})).(*euphoria.EffectEuphoricSource)
}
func handleFromPtr_Ptr_euphoria_EffectEuphoricSource(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*euphoria.EffectEuphoricSource", p))
}

// Converters for pointer handles for type: *euphoria.EffectUltimateEarly
func ptrFromHandle_Ptr_euphoria_EffectUltimateEarly(h CGoHandle) *euphoria.EffectUltimateEarly {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*euphoria.EffectUltimateEarly")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(euphoria.EffectUltimateEarly{})).(*euphoria.EffectUltimateEarly)
}
func handleFromPtr_Ptr_euphoria_EffectUltimateEarly(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*euphoria.EffectUltimateEarly", p))
}

// Converters for non-pointer handles for type: euphoria.EffectEuphoricHeal
func ptrFromHandle_euphoria_EffectEuphoricHeal(h CGoHandle) *euphoria.EffectEuphoricHeal {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "euphoria.EffectEuphoricHeal")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(euphoria.EffectEuphoricHeal{})).(*euphoria.EffectEuphoricHeal)
}
func handleFromPtr_euphoria_EffectEuphoricHeal(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("euphoria.EffectEuphoricHeal", p))
}

// Converters for non-pointer handles for type: euphoria.EffectEuphoricSource
func ptrFromHandle_euphoria_EffectEuphoricSource(h CGoHandle) *euphoria.EffectEuphoricSource {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "euphoria.EffectEuphoricSource")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(euphoria.EffectEuphoricSource{})).(*euphoria.EffectEuphoricSource)
}
func handleFromPtr_euphoria_EffectEuphoricSource(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("euphoria.EffectEuphoricSource", p))
}

// Converters for non-pointer handles for type: euphoria.EffectUltimateEarly
func ptrFromHandle_euphoria_EffectUltimateEarly(h CGoHandle) *euphoria.EffectUltimateEarly {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "euphoria.EffectUltimateEarly")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(euphoria.EffectUltimateEarly{})).(*euphoria.EffectUltimateEarly)
}
func handleFromPtr_euphoria_EffectUltimateEarly(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("euphoria.EffectUltimateEarly", p))
}

// ---- Global Variables: can only use functions to access ---
//
//export euphoria_CharacterEuphoria
func euphoria_CharacterEuphoria() CGoHandle {
	return handleFromPtr_Ptr_game_CharacterData(euphoria.CharacterEuphoria)
}

//export euphoria_Set_CharacterEuphoria
func euphoria_Set_CharacterEuphoria(val CGoHandle) {
	euphoria.CharacterEuphoria = ptrFromHandle_Ptr_game_CharacterData(val)
}

//export euphoria_EffectDescEuphoricHeal
func euphoria_EffectDescEuphoricHeal() CGoHandle {
	return handleFromPtr_game_EffectDescription(&euphoria.EffectDescEuphoricHeal)
}

//export euphoria_Set_EffectDescEuphoricHeal
func euphoria_Set_EffectDescEuphoricHeal(val CGoHandle) {
	euphoria.EffectDescEuphoricHeal = *ptrFromHandle_game_EffectDescription(val)
}

//export euphoria_EffectDescEuphoricSource
func euphoria_EffectDescEuphoricSource() CGoHandle {
	return handleFromPtr_game_EffectDescription(&euphoria.EffectDescEuphoricSource)
}

//export euphoria_Set_EffectDescEuphoricSource
func euphoria_Set_EffectDescEuphoricSource(val CGoHandle) {
	euphoria.EffectDescEuphoricSource = *ptrFromHandle_game_EffectDescription(val)
}

//export euphoria_EffectDescUltimateEarly
func euphoria_EffectDescUltimateEarly() CGoHandle {
	return handleFromPtr_game_EffectDescription(&euphoria.EffectDescUltimateEarly)
}

//export euphoria_Set_EffectDescUltimateEarly
func euphoria_Set_EffectDescUltimateEarly(val CGoHandle) {
	euphoria.EffectDescUltimateEarly = *ptrFromHandle_game_EffectDescription(val)
}

//export euphoria_SkillAmpleness
func euphoria_SkillAmpleness() CGoHandle {
	return handleFromPtr_Ptr_game_SkillData(euphoria.SkillAmpleness)
}

//export euphoria_Set_SkillAmpleness
func euphoria_Set_SkillAmpleness(val CGoHandle) {
	euphoria.SkillAmpleness = ptrFromHandle_Ptr_game_SkillData(val)
}

//export euphoria_SkillEuphoria
func euphoria_SkillEuphoria() CGoHandle {
	return handleFromPtr_Ptr_game_SkillData(euphoria.SkillEuphoria)
}

//export euphoria_Set_SkillEuphoria
func euphoria_Set_SkillEuphoria(val CGoHandle) {
	euphoria.SkillEuphoria = ptrFromHandle_Ptr_game_SkillData(val)
}

//export euphoria_SkillExuberance
func euphoria_SkillExuberance() CGoHandle {
	return handleFromPtr_Ptr_game_SkillData(euphoria.SkillExuberance)
}

//export euphoria_Set_SkillExuberance
func euphoria_Set_SkillExuberance(val CGoHandle) {
	euphoria.SkillExuberance = ptrFromHandle_Ptr_game_SkillData(val)
}

//export euphoria_SkillPinkSphere
func euphoria_SkillPinkSphere() CGoHandle {
	return handleFromPtr_Ptr_game_SkillData(euphoria.SkillPinkSphere)
}

//export euphoria_Set_SkillPinkSphere
func euphoria_Set_SkillPinkSphere(val CGoHandle) {
	euphoria.SkillPinkSphere = ptrFromHandle_Ptr_game_SkillData(val)
}

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: euphoria.EffectEuphoricHeal ---
//
//export euphoria_EffectEuphoricHeal_CTor
func euphoria_EffectEuphoricHeal_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_euphoria_EffectEuphoricHeal(&euphoria.EffectEuphoricHeal{}))
}

//export euphoria_EffectEuphoricHeal_Desc
func euphoria_EffectEuphoricHeal_Desc(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*euphoria.EffectEuphoricHeal")
	if __err != nil {
		return handleFromPtr_game_EffectDescription(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(euphoria.EffectEuphoricHeal{})).(*euphoria.EffectEuphoricHeal).Desc()

	return handleFromPtr_game_EffectDescription(&cret)
}

//export euphoria_EffectEuphoricHeal_Clone
func euphoria_EffectEuphoricHeal_Clone(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*euphoria.EffectEuphoricHeal")
	if __err != nil {
		return handleFromPtr_game_Effect(nil)
	}
	return handleFromPtr_game_Effect(gopyh.Embed(vifc, reflect.TypeOf(euphoria.EffectEuphoricHeal{})).(*euphoria.EffectEuphoricHeal).Clone())

}

//export euphoria_EffectEuphoricHeal_OnTurnEnd
func euphoria_EffectEuphoricHeal_OnTurnEnd(_handle CGoHandle, c CGoHandle, opp CGoHandle, turnState CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*euphoria.EffectEuphoricHeal")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(euphoria.EffectEuphoricHeal{})).(*euphoria.EffectEuphoricHeal).OnTurnEnd(ptrFromHandle_Ptr_game_Character(c), ptrFromHandle_Ptr_game_Character(opp), *ptrFromHandle_game_TurnState(turnState))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(euphoria.EffectEuphoricHeal{})).(*euphoria.EffectEuphoricHeal).OnTurnEnd(ptrFromHandle_Ptr_game_Character(c), ptrFromHandle_Ptr_game_Character(opp), *ptrFromHandle_game_TurnState(turnState))
	}
}

// --- wrapping struct: euphoria.EffectEuphoricSource ---
//
//export euphoria_EffectEuphoricSource_CTor
func euphoria_EffectEuphoricSource_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_euphoria_EffectEuphoricSource(&euphoria.EffectEuphoricSource{}))
}

//export euphoria_EffectEuphoricSource_Desc
func euphoria_EffectEuphoricSource_Desc(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*euphoria.EffectEuphoricSource")
	if __err != nil {
		return handleFromPtr_game_EffectDescription(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(euphoria.EffectEuphoricSource{})).(*euphoria.EffectEuphoricSource).Desc()

	return handleFromPtr_game_EffectDescription(&cret)
}

//export euphoria_EffectEuphoricSource_Clone
func euphoria_EffectEuphoricSource_Clone(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*euphoria.EffectEuphoricSource")
	if __err != nil {
		return handleFromPtr_game_Effect(nil)
	}
	return handleFromPtr_game_Effect(gopyh.Embed(vifc, reflect.TypeOf(euphoria.EffectEuphoricSource{})).(*euphoria.EffectEuphoricSource).Clone())

}

// --- wrapping struct: euphoria.EffectUltimateEarly ---
//
//export euphoria_EffectUltimateEarly_CTor
func euphoria_EffectUltimateEarly_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_euphoria_EffectUltimateEarly(&euphoria.EffectUltimateEarly{}))
}

//export euphoria_EffectUltimateEarly_Desc
func euphoria_EffectUltimateEarly_Desc(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*euphoria.EffectUltimateEarly")
	if __err != nil {
		return handleFromPtr_game_EffectDescription(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(euphoria.EffectUltimateEarly{})).(*euphoria.EffectUltimateEarly).Desc()

	return handleFromPtr_game_EffectDescription(&cret)
}

//export euphoria_EffectUltimateEarly_Clone
func euphoria_EffectUltimateEarly_Clone(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*euphoria.EffectUltimateEarly")
	if __err != nil {
		return handleFromPtr_game_Effect(nil)
	}
	return handleFromPtr_game_Effect(gopyh.Embed(vifc, reflect.TypeOf(euphoria.EffectUltimateEarly{})).(*euphoria.EffectUltimateEarly).Clone())

}

//export euphoria_EffectUltimateEarly_Amount
func euphoria_EffectUltimateEarly_Amount(_handle CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*euphoria.EffectUltimateEarly")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(gopyh.Embed(vifc, reflect.TypeOf(euphoria.EffectUltimateEarly{})).(*euphoria.EffectUltimateEarly).Amount())

}

//export euphoria_EffectUltimateEarly_Increase
func euphoria_EffectUltimateEarly_Increase(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*euphoria.EffectUltimateEarly")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(euphoria.EffectUltimateEarly{})).(*euphoria.EffectUltimateEarly).Increase()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(euphoria.EffectUltimateEarly{})).(*euphoria.EffectUltimateEarly).Increase()
	}
}

//export euphoria_EffectUltimateEarly_ModifySkillUnlockTurn
func euphoria_EffectUltimateEarly_ModifySkillUnlockTurn(_handle CGoHandle, s CGoHandle, unlockTurn C.longlong) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*euphoria.EffectUltimateEarly")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(gopyh.Embed(vifc, reflect.TypeOf(euphoria.EffectUltimateEarly{})).(*euphoria.EffectUltimateEarly).ModifySkillUnlockTurn(ptrFromHandle_Ptr_game_Skill(s), int(unlockTurn)))

}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export euphoria_NewEffectEuphoricSource
func euphoria_NewEffectEuphoricSource(amount C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := euphoria.NewEffectEuphoricSource(int(amount))

	return handleFromPtr_euphoria_EffectEuphoricSource(&cret)
}

//export euphoria_NewEffectUltimateEarly
func euphoria_NewEffectUltimateEarly() CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_euphoria_EffectUltimateEarly(euphoria.NewEffectUltimateEarly())

}

// ---- Functions ---

// ---- Package: milana ---

// ---- Types ---

// Converters for pointer handles for type: *milana.EffectMintMist
func ptrFromHandle_Ptr_milana_EffectMintMist(h CGoHandle) *milana.EffectMintMist {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*milana.EffectMintMist")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(milana.EffectMintMist{})).(*milana.EffectMintMist)
}
func handleFromPtr_Ptr_milana_EffectMintMist(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*milana.EffectMintMist", p))
}

// Converters for pointer handles for type: *milana.EffectStolenHP
func ptrFromHandle_Ptr_milana_EffectStolenHP(h CGoHandle) *milana.EffectStolenHP {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*milana.EffectStolenHP")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(milana.EffectStolenHP{})).(*milana.EffectStolenHP)
}
func handleFromPtr_Ptr_milana_EffectStolenHP(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*milana.EffectStolenHP", p))
}

// Converters for non-pointer handles for type: milana.EffectMintMist
func ptrFromHandle_milana_EffectMintMist(h CGoHandle) *milana.EffectMintMist {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "milana.EffectMintMist")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(milana.EffectMintMist{})).(*milana.EffectMintMist)
}
func handleFromPtr_milana_EffectMintMist(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("milana.EffectMintMist", p))
}

// Converters for non-pointer handles for type: milana.EffectStolenHP
func ptrFromHandle_milana_EffectStolenHP(h CGoHandle) *milana.EffectStolenHP {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "milana.EffectStolenHP")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(milana.EffectStolenHP{})).(*milana.EffectStolenHP)
}
func handleFromPtr_milana_EffectStolenHP(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("milana.EffectStolenHP", p))
}

// ---- Global Variables: can only use functions to access ---
//
//export milana_CharacterMilana
func milana_CharacterMilana() CGoHandle {
	return handleFromPtr_Ptr_game_CharacterData(milana.CharacterMilana)
}

//export milana_Set_CharacterMilana
func milana_Set_CharacterMilana(val CGoHandle) {
	milana.CharacterMilana = ptrFromHandle_Ptr_game_CharacterData(val)
}

//export milana_EffectDescMintMist
func milana_EffectDescMintMist() CGoHandle {
	return handleFromPtr_game_EffectDescription(&milana.EffectDescMintMist)
}

//export milana_Set_EffectDescMintMist
func milana_Set_EffectDescMintMist(val CGoHandle) {
	milana.EffectDescMintMist = *ptrFromHandle_game_EffectDescription(val)
}

//export milana_EffectDescStolenHP
func milana_EffectDescStolenHP() CGoHandle {
	return handleFromPtr_game_EffectDescription(&milana.EffectDescStolenHP)
}

//export milana_Set_EffectDescStolenHP
func milana_Set_EffectDescStolenHP(val CGoHandle) {
	milana.EffectDescStolenHP = *ptrFromHandle_game_EffectDescription(val)
}

//export milana_SkillComposure
func milana_SkillComposure() CGoHandle {
	return handleFromPtr_Ptr_game_SkillData(milana.SkillComposure)
}

//export milana_Set_SkillComposure
func milana_Set_SkillComposure(val CGoHandle) {
	milana.SkillComposure = ptrFromHandle_Ptr_game_SkillData(val)
}

//export milana_SkillMintMist
func milana_SkillMintMist() CGoHandle {
	return handleFromPtr_Ptr_game_SkillData(milana.SkillMintMist)
}

//export milana_Set_SkillMintMist
func milana_Set_SkillMintMist(val CGoHandle) {
	milana.SkillMintMist = ptrFromHandle_Ptr_game_SkillData(val)
}

//export milana_SkillPride
func milana_SkillPride() CGoHandle {
	return handleFromPtr_Ptr_game_SkillData(milana.SkillPride)
}

//export milana_Set_SkillPride
func milana_Set_SkillPride(val CGoHandle) {
	milana.SkillPride = ptrFromHandle_Ptr_game_SkillData(val)
}

//export milana_SkillRoyalMove
func milana_SkillRoyalMove() CGoHandle {
	return handleFromPtr_Ptr_game_SkillData(milana.SkillRoyalMove)
}

//export milana_Set_SkillRoyalMove
func milana_Set_SkillRoyalMove(val CGoHandle) {
	milana.SkillRoyalMove = ptrFromHandle_Ptr_game_SkillData(val)
}

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: milana.EffectMintMist ---
//
//export milana_EffectMintMist_CTor
func milana_EffectMintMist_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_milana_EffectMintMist(&milana.EffectMintMist{}))
}

//export milana_EffectMintMist_Desc
func milana_EffectMintMist_Desc(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*milana.EffectMintMist")
	if __err != nil {
		return handleFromPtr_game_EffectDescription(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(milana.EffectMintMist{})).(*milana.EffectMintMist).Desc()

	return handleFromPtr_game_EffectDescription(&cret)
}

//export milana_EffectMintMist_Clone
func milana_EffectMintMist_Clone(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*milana.EffectMintMist")
	if __err != nil {
		return handleFromPtr_game_Effect(nil)
	}
	return handleFromPtr_game_Effect(gopyh.Embed(vifc, reflect.TypeOf(milana.EffectMintMist{})).(*milana.EffectMintMist).Clone())

}

//export milana_EffectMintMist_IsEffectAllowed
func milana_EffectMintMist_IsEffectAllowed(_handle CGoHandle, eff CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*milana.EffectMintMist")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(gopyh.Embed(vifc, reflect.TypeOf(milana.EffectMintMist{})).(*milana.EffectMintMist).IsEffectAllowed(ptrFromHandle_game_Effect(eff)))

}

// --- wrapping struct: milana.EffectStolenHP ---
//
//export milana_EffectStolenHP_CTor
func milana_EffectStolenHP_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_milana_EffectStolenHP(&milana.EffectStolenHP{}))
}

//export milana_EffectStolenHP_Desc
func milana_EffectStolenHP_Desc(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*milana.EffectStolenHP")
	if __err != nil {
		return handleFromPtr_game_EffectDescription(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(milana.EffectStolenHP{})).(*milana.EffectStolenHP).Desc()

	return handleFromPtr_game_EffectDescription(&cret)
}

//export milana_EffectStolenHP_Clone
func milana_EffectStolenHP_Clone(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*milana.EffectStolenHP")
	if __err != nil {
		return handleFromPtr_game_Effect(nil)
	}
	return handleFromPtr_game_Effect(gopyh.Embed(vifc, reflect.TypeOf(milana.EffectStolenHP{})).(*milana.EffectStolenHP).Clone())

}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export milana_NewEffectMintMist
func milana_NewEffectMintMist(turnState CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := milana.NewEffectMintMist(*ptrFromHandle_game_TurnState(turnState))

	return handleFromPtr_milana_EffectMintMist(&cret)
}

//export milana_NewEffectStolenHP
func milana_NewEffectStolenHP(amount C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := milana.NewEffectStolenHP(int(amount))

	return handleFromPtr_milana_EffectStolenHP(&cret)
}

// ---- Functions ---

// ---- Package: ruby ---

// ---- Types ---

// Converters for pointer handles for type: *ruby.EffectCannotHeal
func ptrFromHandle_Ptr_ruby_EffectCannotHeal(h CGoHandle) *ruby.EffectCannotHeal {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*ruby.EffectCannotHeal")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ruby.EffectCannotHeal{})).(*ruby.EffectCannotHeal)
}
func handleFromPtr_Ptr_ruby_EffectCannotHeal(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*ruby.EffectCannotHeal", p))
}

// Converters for pointer handles for type: *ruby.EffectDoubleDamage
func ptrFromHandle_Ptr_ruby_EffectDoubleDamage(h CGoHandle) *ruby.EffectDoubleDamage {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*ruby.EffectDoubleDamage")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ruby.EffectDoubleDamage{})).(*ruby.EffectDoubleDamage)
}
func handleFromPtr_Ptr_ruby_EffectDoubleDamage(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*ruby.EffectDoubleDamage", p))
}

// Converters for non-pointer handles for type: ruby.EffectCannotHeal
func ptrFromHandle_ruby_EffectCannotHeal(h CGoHandle) *ruby.EffectCannotHeal {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ruby.EffectCannotHeal")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ruby.EffectCannotHeal{})).(*ruby.EffectCannotHeal)
}
func handleFromPtr_ruby_EffectCannotHeal(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ruby.EffectCannotHeal", p))
}

// Converters for non-pointer handles for type: ruby.EffectDoubleDamage
func ptrFromHandle_ruby_EffectDoubleDamage(h CGoHandle) *ruby.EffectDoubleDamage {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ruby.EffectDoubleDamage")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ruby.EffectDoubleDamage{})).(*ruby.EffectDoubleDamage)
}
func handleFromPtr_ruby_EffectDoubleDamage(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ruby.EffectDoubleDamage", p))
}

// ---- Global Variables: can only use functions to access ---
//
//export ruby_CharacterRuby
func ruby_CharacterRuby() CGoHandle {
	return handleFromPtr_Ptr_game_CharacterData(ruby.CharacterRuby)
}

//export ruby_Set_CharacterRuby
func ruby_Set_CharacterRuby(val CGoHandle) {
	ruby.CharacterRuby = ptrFromHandle_Ptr_game_CharacterData(val)
}

//export ruby_EffectDescCannotHeal
func ruby_EffectDescCannotHeal() CGoHandle {
	return handleFromPtr_game_EffectDescription(&ruby.EffectDescCannotHeal)
}

//export ruby_Set_EffectDescCannotHeal
func ruby_Set_EffectDescCannotHeal(val CGoHandle) {
	ruby.EffectDescCannotHeal = *ptrFromHandle_game_EffectDescription(val)
}

//export ruby_EffectDescDoubleDamage
func ruby_EffectDescDoubleDamage() CGoHandle {
	return handleFromPtr_game_EffectDescription(&ruby.EffectDescDoubleDamage)
}

//export ruby_Set_EffectDescDoubleDamage
func ruby_Set_EffectDescDoubleDamage(val CGoHandle) {
	ruby.EffectDescDoubleDamage = *ptrFromHandle_game_EffectDescription(val)
}

//export ruby_SkillDance
func ruby_SkillDance() CGoHandle {
	return handleFromPtr_Ptr_game_SkillData(ruby.SkillDance)
}

//export ruby_Set_SkillDance
func ruby_Set_SkillDance(val CGoHandle) {
	ruby.SkillDance = ptrFromHandle_Ptr_game_SkillData(val)
}

//export ruby_SkillExecute
func ruby_SkillExecute() CGoHandle {
	return handleFromPtr_Ptr_game_SkillData(ruby.SkillExecute)
}

//export ruby_Set_SkillExecute
func ruby_Set_SkillExecute(val CGoHandle) {
	ruby.SkillExecute = ptrFromHandle_Ptr_game_SkillData(val)
}

//export ruby_SkillRage
func ruby_SkillRage() CGoHandle {
	return handleFromPtr_Ptr_game_SkillData(ruby.SkillRage)
}

//export ruby_Set_SkillRage
func ruby_Set_SkillRage(val CGoHandle) {
	ruby.SkillRage = ptrFromHandle_Ptr_game_SkillData(val)
}

//export ruby_SkillStop
func ruby_SkillStop() CGoHandle {
	return handleFromPtr_Ptr_game_SkillData(ruby.SkillStop)
}

//export ruby_Set_SkillStop
func ruby_Set_SkillStop(val CGoHandle) {
	ruby.SkillStop = ptrFromHandle_Ptr_game_SkillData(val)
}

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: ruby.EffectCannotHeal ---
//
//export ruby_EffectCannotHeal_CTor
func ruby_EffectCannotHeal_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_ruby_EffectCannotHeal(&ruby.EffectCannotHeal{}))
}

//export ruby_EffectCannotHeal_Desc
func ruby_EffectCannotHeal_Desc(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ruby.EffectCannotHeal")
	if __err != nil {
		return handleFromPtr_game_EffectDescription(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(ruby.EffectCannotHeal{})).(*ruby.EffectCannotHeal).Desc()

	return handleFromPtr_game_EffectDescription(&cret)
}

//export ruby_EffectCannotHeal_Clone
func ruby_EffectCannotHeal_Clone(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ruby.EffectCannotHeal")
	if __err != nil {
		return handleFromPtr_game_Effect(nil)
	}
	return handleFromPtr_game_Effect(gopyh.Embed(vifc, reflect.TypeOf(ruby.EffectCannotHeal{})).(*ruby.EffectCannotHeal).Clone())

}

//export ruby_EffectCannotHeal_IsHealAllowed
func ruby_EffectCannotHeal_IsHealAllowed(_handle CGoHandle, heal C.longlong) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ruby.EffectCannotHeal")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(gopyh.Embed(vifc, reflect.TypeOf(ruby.EffectCannotHeal{})).(*ruby.EffectCannotHeal).IsHealAllowed(int(heal)))

}

// --- wrapping struct: ruby.EffectDoubleDamage ---
//
//export ruby_EffectDoubleDamage_CTor
func ruby_EffectDoubleDamage_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_ruby_EffectDoubleDamage(&ruby.EffectDoubleDamage{}))
}

//export ruby_EffectDoubleDamage_Desc
func ruby_EffectDoubleDamage_Desc(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ruby.EffectDoubleDamage")
	if __err != nil {
		return handleFromPtr_game_EffectDescription(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(ruby.EffectDoubleDamage{})).(*ruby.EffectDoubleDamage).Desc()

	return handleFromPtr_game_EffectDescription(&cret)
}

//export ruby_EffectDoubleDamage_Clone
func ruby_EffectDoubleDamage_Clone(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ruby.EffectDoubleDamage")
	if __err != nil {
		return handleFromPtr_game_Effect(nil)
	}
	return handleFromPtr_game_Effect(gopyh.Embed(vifc, reflect.TypeOf(ruby.EffectDoubleDamage{})).(*ruby.EffectDoubleDamage).Clone())

}

//export ruby_EffectDoubleDamage_ModifyDealtDamage
func ruby_EffectDoubleDamage_ModifyDealtDamage(_handle CGoHandle, dmg C.longlong, colour C.longlong) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ruby.EffectDoubleDamage")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(gopyh.Embed(vifc, reflect.TypeOf(ruby.EffectDoubleDamage{})).(*ruby.EffectDoubleDamage).ModifyDealtDamage(int(dmg), game.Colour(int(colour))))

}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export ruby_NewEffectCannotHeal
func ruby_NewEffectCannotHeal(turnState CGoHandle, isOpp C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := ruby.NewEffectCannotHeal(*ptrFromHandle_game_TurnState(turnState), boolPyToGo(isOpp))

	return handleFromPtr_ruby_EffectCannotHeal(&cret)
}

//export ruby_NewEffectDoubleDamage
func ruby_NewEffectDoubleDamage(turnState CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := ruby.NewEffectDoubleDamage(*ptrFromHandle_game_TurnState(turnState))

	return handleFromPtr_ruby_EffectDoubleDamage(&cret)
}

// ---- Functions ---

// ---- Package: speed ---

// ---- Types ---

// Converters for pointer handles for type: *speed.EffectBlackTokens
func ptrFromHandle_Ptr_speed_EffectBlackTokens(h CGoHandle) *speed.EffectBlackTokens {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*speed.EffectBlackTokens")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(speed.EffectBlackTokens{})).(*speed.EffectBlackTokens)
}
func handleFromPtr_Ptr_speed_EffectBlackTokens(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*speed.EffectBlackTokens", p))
}

// Converters for pointer handles for type: *speed.EffectDamageReduced
func ptrFromHandle_Ptr_speed_EffectDamageReduced(h CGoHandle) *speed.EffectDamageReduced {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*speed.EffectDamageReduced")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(speed.EffectDamageReduced{})).(*speed.EffectDamageReduced)
}
func handleFromPtr_Ptr_speed_EffectDamageReduced(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*speed.EffectDamageReduced", p))
}

// Converters for pointer handles for type: *speed.EffectDefenceReduced
func ptrFromHandle_Ptr_speed_EffectDefenceReduced(h CGoHandle) *speed.EffectDefenceReduced {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*speed.EffectDefenceReduced")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(speed.EffectDefenceReduced{})).(*speed.EffectDefenceReduced)
}
func handleFromPtr_Ptr_speed_EffectDefenceReduced(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*speed.EffectDefenceReduced", p))
}

// Converters for pointer handles for type: *speed.EffectGreenTokens
func ptrFromHandle_Ptr_speed_EffectGreenTokens(h CGoHandle) *speed.EffectGreenTokens {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*speed.EffectGreenTokens")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(speed.EffectGreenTokens{})).(*speed.EffectGreenTokens)
}
func handleFromPtr_Ptr_speed_EffectGreenTokens(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*speed.EffectGreenTokens", p))
}

// Converters for pointer handles for type: *speed.EffectSpedUp
func ptrFromHandle_Ptr_speed_EffectSpedUp(h CGoHandle) *speed.EffectSpedUp {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*speed.EffectSpedUp")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(speed.EffectSpedUp{})).(*speed.EffectSpedUp)
}
func handleFromPtr_Ptr_speed_EffectSpedUp(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*speed.EffectSpedUp", p))
}

// Converters for non-pointer handles for type: speed.EffectBlackTokens
func ptrFromHandle_speed_EffectBlackTokens(h CGoHandle) *speed.EffectBlackTokens {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "speed.EffectBlackTokens")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(speed.EffectBlackTokens{})).(*speed.EffectBlackTokens)
}
func handleFromPtr_speed_EffectBlackTokens(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("speed.EffectBlackTokens", p))
}

// Converters for non-pointer handles for type: speed.EffectDamageReduced
func ptrFromHandle_speed_EffectDamageReduced(h CGoHandle) *speed.EffectDamageReduced {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "speed.EffectDamageReduced")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(speed.EffectDamageReduced{})).(*speed.EffectDamageReduced)
}
func handleFromPtr_speed_EffectDamageReduced(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("speed.EffectDamageReduced", p))
}

// Converters for non-pointer handles for type: speed.EffectDefenceReduced
func ptrFromHandle_speed_EffectDefenceReduced(h CGoHandle) *speed.EffectDefenceReduced {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "speed.EffectDefenceReduced")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(speed.EffectDefenceReduced{})).(*speed.EffectDefenceReduced)
}
func handleFromPtr_speed_EffectDefenceReduced(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("speed.EffectDefenceReduced", p))
}

// Converters for non-pointer handles for type: speed.EffectGreenTokens
func ptrFromHandle_speed_EffectGreenTokens(h CGoHandle) *speed.EffectGreenTokens {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "speed.EffectGreenTokens")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(speed.EffectGreenTokens{})).(*speed.EffectGreenTokens)
}
func handleFromPtr_speed_EffectGreenTokens(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("speed.EffectGreenTokens", p))
}

// Converters for non-pointer handles for type: speed.EffectSpedUp
func ptrFromHandle_speed_EffectSpedUp(h CGoHandle) *speed.EffectSpedUp {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "speed.EffectSpedUp")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(speed.EffectSpedUp{})).(*speed.EffectSpedUp)
}
func handleFromPtr_speed_EffectSpedUp(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("speed.EffectSpedUp", p))
}

// ---- Global Variables: can only use functions to access ---
//
//export speed_CharacterSpeed
func speed_CharacterSpeed() CGoHandle {
	return handleFromPtr_Ptr_game_CharacterData(speed.CharacterSpeed)
}

//export speed_Set_CharacterSpeed
func speed_Set_CharacterSpeed(val CGoHandle) {
	speed.CharacterSpeed = ptrFromHandle_Ptr_game_CharacterData(val)
}

//export speed_EffectDescBlackTokens
func speed_EffectDescBlackTokens() CGoHandle {
	return handleFromPtr_game_EffectDescription(&speed.EffectDescBlackTokens)
}

//export speed_Set_EffectDescBlackTokens
func speed_Set_EffectDescBlackTokens(val CGoHandle) {
	speed.EffectDescBlackTokens = *ptrFromHandle_game_EffectDescription(val)
}

//export speed_EffectDescDamageReduced
func speed_EffectDescDamageReduced() CGoHandle {
	return handleFromPtr_game_EffectDescription(&speed.EffectDescDamageReduced)
}

//export speed_Set_EffectDescDamageReduced
func speed_Set_EffectDescDamageReduced(val CGoHandle) {
	speed.EffectDescDamageReduced = *ptrFromHandle_game_EffectDescription(val)
}

//export speed_EffectDescDefenceReduced
func speed_EffectDescDefenceReduced() CGoHandle {
	return handleFromPtr_game_EffectDescription(&speed.EffectDescDefenceReduced)
}

//export speed_Set_EffectDescDefenceReduced
func speed_Set_EffectDescDefenceReduced(val CGoHandle) {
	speed.EffectDescDefenceReduced = *ptrFromHandle_game_EffectDescription(val)
}

//export speed_EffectDescGreenTokens
func speed_EffectDescGreenTokens() CGoHandle {
	return handleFromPtr_game_EffectDescription(&speed.EffectDescGreenTokens)
}

//export speed_Set_EffectDescGreenTokens
func speed_Set_EffectDescGreenTokens(val CGoHandle) {
	speed.EffectDescGreenTokens = *ptrFromHandle_game_EffectDescription(val)
}

//export speed_EffectDescSpedUp
func speed_EffectDescSpedUp() CGoHandle {
	return handleFromPtr_game_EffectDescription(&speed.EffectDescSpedUp)
}

//export speed_Set_EffectDescSpedUp
func speed_Set_EffectDescSpedUp(val CGoHandle) {
	speed.EffectDescSpedUp = *ptrFromHandle_game_EffectDescription(val)
}

//export speed_SkillRun
func speed_SkillRun() CGoHandle {
	return handleFromPtr_Ptr_game_SkillData(speed.SkillRun)
}

//export speed_Set_SkillRun
func speed_Set_SkillRun(val CGoHandle) {
	speed.SkillRun = ptrFromHandle_Ptr_game_SkillData(val)
}

//export speed_SkillSpeed
func speed_SkillSpeed() CGoHandle {
	return handleFromPtr_Ptr_game_SkillData(speed.SkillSpeed)
}

//export speed_Set_SkillSpeed
func speed_Set_SkillSpeed(val CGoHandle) {
	speed.SkillSpeed = ptrFromHandle_Ptr_game_SkillData(val)
}

//export speed_SkillStab
func speed_SkillStab() CGoHandle {
	return handleFromPtr_Ptr_game_SkillData(speed.SkillStab)
}

//export speed_Set_SkillStab
func speed_Set_SkillStab(val CGoHandle) {
	speed.SkillStab = ptrFromHandle_Ptr_game_SkillData(val)
}

//export speed_SkillWeaken
func speed_SkillWeaken() CGoHandle {
	return handleFromPtr_Ptr_game_SkillData(speed.SkillWeaken)
}

//export speed_Set_SkillWeaken
func speed_Set_SkillWeaken(val CGoHandle) {
	speed.SkillWeaken = ptrFromHandle_Ptr_game_SkillData(val)
}

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: speed.EffectBlackTokens ---
//
//export speed_EffectBlackTokens_CTor
func speed_EffectBlackTokens_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_speed_EffectBlackTokens(&speed.EffectBlackTokens{}))
}

//export speed_EffectBlackTokens_Desc
func speed_EffectBlackTokens_Desc(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*speed.EffectBlackTokens")
	if __err != nil {
		return handleFromPtr_game_EffectDescription(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(speed.EffectBlackTokens{})).(*speed.EffectBlackTokens).Desc()

	return handleFromPtr_game_EffectDescription(&cret)
}

//export speed_EffectBlackTokens_Clone
func speed_EffectBlackTokens_Clone(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*speed.EffectBlackTokens")
	if __err != nil {
		return handleFromPtr_game_Effect(nil)
	}
	return handleFromPtr_game_Effect(gopyh.Embed(vifc, reflect.TypeOf(speed.EffectBlackTokens{})).(*speed.EffectBlackTokens).Clone())

}

// --- wrapping struct: speed.EffectDamageReduced ---
//
//export speed_EffectDamageReduced_CTor
func speed_EffectDamageReduced_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_speed_EffectDamageReduced(&speed.EffectDamageReduced{}))
}

//export speed_EffectDamageReduced_Desc
func speed_EffectDamageReduced_Desc(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*speed.EffectDamageReduced")
	if __err != nil {
		return handleFromPtr_game_EffectDescription(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(speed.EffectDamageReduced{})).(*speed.EffectDamageReduced).Desc()

	return handleFromPtr_game_EffectDescription(&cret)
}

//export speed_EffectDamageReduced_Clone
func speed_EffectDamageReduced_Clone(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*speed.EffectDamageReduced")
	if __err != nil {
		return handleFromPtr_game_Effect(nil)
	}
	return handleFromPtr_game_Effect(gopyh.Embed(vifc, reflect.TypeOf(speed.EffectDamageReduced{})).(*speed.EffectDamageReduced).Clone())

}

//export speed_EffectDamageReduced_Amount
func speed_EffectDamageReduced_Amount(_handle CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*speed.EffectDamageReduced")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(gopyh.Embed(vifc, reflect.TypeOf(speed.EffectDamageReduced{})).(*speed.EffectDamageReduced).Amount())

}

//export speed_EffectDamageReduced_Increase
func speed_EffectDamageReduced_Increase(_handle CGoHandle, amount C.longlong, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*speed.EffectDamageReduced")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(speed.EffectDamageReduced{})).(*speed.EffectDamageReduced).Increase(int(amount))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(speed.EffectDamageReduced{})).(*speed.EffectDamageReduced).Increase(int(amount))
	}
}

//export speed_EffectDamageReduced_ModifyTakenDamage
func speed_EffectDamageReduced_ModifyTakenDamage(_handle CGoHandle, dmg C.longlong, colour C.longlong) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*speed.EffectDamageReduced")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(gopyh.Embed(vifc, reflect.TypeOf(speed.EffectDamageReduced{})).(*speed.EffectDamageReduced).ModifyTakenDamage(int(dmg), game.Colour(int(colour))))

}

//export speed_EffectDamageReduced_HasExpired
func speed_EffectDamageReduced_HasExpired(_handle CGoHandle, turnState CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*speed.EffectDamageReduced")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(gopyh.Embed(vifc, reflect.TypeOf(speed.EffectDamageReduced{})).(*speed.EffectDamageReduced).HasExpired(*ptrFromHandle_game_TurnState(turnState)))

}

// --- wrapping struct: speed.EffectDefenceReduced ---
//
//export speed_EffectDefenceReduced_CTor
func speed_EffectDefenceReduced_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_speed_EffectDefenceReduced(&speed.EffectDefenceReduced{}))
}

//export speed_EffectDefenceReduced_Desc
func speed_EffectDefenceReduced_Desc(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*speed.EffectDefenceReduced")
	if __err != nil {
		return handleFromPtr_game_EffectDescription(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(speed.EffectDefenceReduced{})).(*speed.EffectDefenceReduced).Desc()

	return handleFromPtr_game_EffectDescription(&cret)
}

//export speed_EffectDefenceReduced_Clone
func speed_EffectDefenceReduced_Clone(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*speed.EffectDefenceReduced")
	if __err != nil {
		return handleFromPtr_game_Effect(nil)
	}
	return handleFromPtr_game_Effect(gopyh.Embed(vifc, reflect.TypeOf(speed.EffectDefenceReduced{})).(*speed.EffectDefenceReduced).Clone())

}

//export speed_EffectDefenceReduced_ModifyDefences
func speed_EffectDefenceReduced_ModifyDefences(_handle CGoHandle, mydef CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*speed.EffectDefenceReduced")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(speed.EffectDefenceReduced{})).(*speed.EffectDefenceReduced).ModifyDefences(deptrFromHandle_Map_game_Colour_int(mydef))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(speed.EffectDefenceReduced{})).(*speed.EffectDefenceReduced).ModifyDefences(deptrFromHandle_Map_game_Colour_int(mydef))
	}
}

// --- wrapping struct: speed.EffectGreenTokens ---
//
//export speed_EffectGreenTokens_CTor
func speed_EffectGreenTokens_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_speed_EffectGreenTokens(&speed.EffectGreenTokens{}))
}

//export speed_EffectGreenTokens_Desc
func speed_EffectGreenTokens_Desc(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*speed.EffectGreenTokens")
	if __err != nil {
		return handleFromPtr_game_EffectDescription(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(speed.EffectGreenTokens{})).(*speed.EffectGreenTokens).Desc()

	return handleFromPtr_game_EffectDescription(&cret)
}

//export speed_EffectGreenTokens_Clone
func speed_EffectGreenTokens_Clone(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*speed.EffectGreenTokens")
	if __err != nil {
		return handleFromPtr_game_Effect(nil)
	}
	return handleFromPtr_game_Effect(gopyh.Embed(vifc, reflect.TypeOf(speed.EffectGreenTokens{})).(*speed.EffectGreenTokens).Clone())

}

// --- wrapping struct: speed.EffectSpedUp ---
//
//export speed_EffectSpedUp_CTor
func speed_EffectSpedUp_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_speed_EffectSpedUp(&speed.EffectSpedUp{}))
}

//export speed_EffectSpedUp_Desc
func speed_EffectSpedUp_Desc(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*speed.EffectSpedUp")
	if __err != nil {
		return handleFromPtr_game_EffectDescription(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(speed.EffectSpedUp{})).(*speed.EffectSpedUp).Desc()

	return handleFromPtr_game_EffectDescription(&cret)
}

//export speed_EffectSpedUp_Clone
func speed_EffectSpedUp_Clone(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*speed.EffectSpedUp")
	if __err != nil {
		return handleFromPtr_game_Effect(nil)
	}
	return handleFromPtr_game_Effect(gopyh.Embed(vifc, reflect.TypeOf(speed.EffectSpedUp{})).(*speed.EffectSpedUp).Clone())

}

//export speed_EffectSpedUp_SkillsPerTurn
func speed_EffectSpedUp_SkillsPerTurn(_handle CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*speed.EffectSpedUp")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(gopyh.Embed(vifc, reflect.TypeOf(speed.EffectSpedUp{})).(*speed.EffectSpedUp).SkillsPerTurn())

}

//export speed_EffectSpedUp_IsSkillAvailable
func speed_EffectSpedUp_IsSkillAvailable(_handle CGoHandle, s CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*speed.EffectSpedUp")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(gopyh.Embed(vifc, reflect.TypeOf(speed.EffectSpedUp{})).(*speed.EffectSpedUp).IsSkillAvailable(ptrFromHandle_Ptr_game_Skill(s)))

}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export speed_NewEffectBlackTokens
func speed_NewEffectBlackTokens(number C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := speed.NewEffectBlackTokens(int(number))

	return handleFromPtr_speed_EffectBlackTokens(&cret)
}

//export speed_NewEffectDamageReduced
func speed_NewEffectDamageReduced(amount C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_speed_EffectDamageReduced(speed.NewEffectDamageReduced(int(amount)))

}

//export speed_NewEffectGreenTokens
func speed_NewEffectGreenTokens(number C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := speed.NewEffectGreenTokens(int(number))

	return handleFromPtr_speed_EffectGreenTokens(&cret)
}

//export speed_NewEffectSpedUp
func speed_NewEffectSpedUp(turnState CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := speed.NewEffectSpedUp(*ptrFromHandle_game_TurnState(turnState))

	return handleFromPtr_speed_EffectSpedUp(&cret)
}

// ---- Functions ---

// ---- Package: storyteller ---

// ---- Types ---

// Converters for pointer handles for type: *storyteller.EffectCannotUse
func ptrFromHandle_Ptr_storyteller_EffectCannotUse(h CGoHandle) *storyteller.EffectCannotUse {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*storyteller.EffectCannotUse")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(storyteller.EffectCannotUse{})).(*storyteller.EffectCannotUse)
}
func handleFromPtr_Ptr_storyteller_EffectCannotUse(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*storyteller.EffectCannotUse", p))
}

// Converters for pointer handles for type: *storyteller.EffectControlled
func ptrFromHandle_Ptr_storyteller_EffectControlled(h CGoHandle) *storyteller.EffectControlled {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*storyteller.EffectControlled")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(storyteller.EffectControlled{})).(*storyteller.EffectControlled)
}
func handleFromPtr_Ptr_storyteller_EffectControlled(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*storyteller.EffectControlled", p))
}

// Converters for non-pointer handles for type: storyteller.EffectCannotUse
func ptrFromHandle_storyteller_EffectCannotUse(h CGoHandle) *storyteller.EffectCannotUse {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "storyteller.EffectCannotUse")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(storyteller.EffectCannotUse{})).(*storyteller.EffectCannotUse)
}
func handleFromPtr_storyteller_EffectCannotUse(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("storyteller.EffectCannotUse", p))
}

// Converters for non-pointer handles for type: storyteller.EffectControlled
func ptrFromHandle_storyteller_EffectControlled(h CGoHandle) *storyteller.EffectControlled {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "storyteller.EffectControlled")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(storyteller.EffectControlled{})).(*storyteller.EffectControlled)
}
func handleFromPtr_storyteller_EffectControlled(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("storyteller.EffectControlled", p))
}

// ---- Global Variables: can only use functions to access ---
//
//export storyteller_CharacterStoryteller
func storyteller_CharacterStoryteller() CGoHandle {
	return handleFromPtr_Ptr_game_CharacterData(storyteller.CharacterStoryteller)
}

//export storyteller_Set_CharacterStoryteller
func storyteller_Set_CharacterStoryteller(val CGoHandle) {
	storyteller.CharacterStoryteller = ptrFromHandle_Ptr_game_CharacterData(val)
}

//export storyteller_EffectDescCannotUse
func storyteller_EffectDescCannotUse() CGoHandle {
	return handleFromPtr_game_EffectDescription(&storyteller.EffectDescCannotUse)
}

//export storyteller_Set_EffectDescCannotUse
func storyteller_Set_EffectDescCannotUse(val CGoHandle) {
	storyteller.EffectDescCannotUse = *ptrFromHandle_game_EffectDescription(val)
}

//export storyteller_EffectDescControlled
func storyteller_EffectDescControlled() CGoHandle {
	return handleFromPtr_game_EffectDescription(&storyteller.EffectDescControlled)
}

//export storyteller_Set_EffectDescControlled
func storyteller_Set_EffectDescControlled(val CGoHandle) {
	storyteller.EffectDescControlled = *ptrFromHandle_game_EffectDescription(val)
}

//export storyteller_SkillMyStory
func storyteller_SkillMyStory() CGoHandle {
	return handleFromPtr_Ptr_game_SkillData(storyteller.SkillMyStory)
}

//export storyteller_Set_SkillMyStory
func storyteller_Set_SkillMyStory(val CGoHandle) {
	storyteller.SkillMyStory = ptrFromHandle_Ptr_game_SkillData(val)
}

//export storyteller_SkillYourColour
func storyteller_SkillYourColour() CGoHandle {
	return handleFromPtr_Ptr_game_SkillData(storyteller.SkillYourColour)
}

//export storyteller_Set_SkillYourColour
func storyteller_Set_SkillYourColour(val CGoHandle) {
	storyteller.SkillYourColour = ptrFromHandle_Ptr_game_SkillData(val)
}

//export storyteller_SkillYourDream
func storyteller_SkillYourDream() CGoHandle {
	return handleFromPtr_Ptr_game_SkillData(storyteller.SkillYourDream)
}

//export storyteller_Set_SkillYourDream
func storyteller_Set_SkillYourDream(val CGoHandle) {
	storyteller.SkillYourDream = ptrFromHandle_Ptr_game_SkillData(val)
}

//export storyteller_SkillYourNumber
func storyteller_SkillYourNumber() CGoHandle {
	return handleFromPtr_Ptr_game_SkillData(storyteller.SkillYourNumber)
}

//export storyteller_Set_SkillYourNumber
func storyteller_Set_SkillYourNumber(val CGoHandle) {
	storyteller.SkillYourNumber = ptrFromHandle_Ptr_game_SkillData(val)
}

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: storyteller.EffectCannotUse ---
//
//export storyteller_EffectCannotUse_CTor
func storyteller_EffectCannotUse_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_storyteller_EffectCannotUse(&storyteller.EffectCannotUse{}))
}

//export storyteller_EffectCannotUse_Desc
func storyteller_EffectCannotUse_Desc(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*storyteller.EffectCannotUse")
	if __err != nil {
		return handleFromPtr_game_EffectDescription(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(storyteller.EffectCannotUse{})).(*storyteller.EffectCannotUse).Desc()

	return handleFromPtr_game_EffectDescription(&cret)
}

//export storyteller_EffectCannotUse_Clone
func storyteller_EffectCannotUse_Clone(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*storyteller.EffectCannotUse")
	if __err != nil {
		return handleFromPtr_game_Effect(nil)
	}
	return handleFromPtr_game_Effect(gopyh.Embed(vifc, reflect.TypeOf(storyteller.EffectCannotUse{})).(*storyteller.EffectCannotUse).Clone())

}

//export storyteller_EffectCannotUse_Colour
func storyteller_EffectCannotUse_Colour(_handle CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*storyteller.EffectCannotUse")
	if __err != nil {
		return C.longlong(int(0))
	}
	return C.longlong(int(gopyh.Embed(vifc, reflect.TypeOf(storyteller.EffectCannotUse{})).(*storyteller.EffectCannotUse).Colour()))

}

//export storyteller_EffectCannotUse_IsSkillAvailable
func storyteller_EffectCannotUse_IsSkillAvailable(_handle CGoHandle, s CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*storyteller.EffectCannotUse")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(gopyh.Embed(vifc, reflect.TypeOf(storyteller.EffectCannotUse{})).(*storyteller.EffectCannotUse).IsSkillAvailable(ptrFromHandle_Ptr_game_Skill(s)))

}

// --- wrapping struct: storyteller.EffectControlled ---
//
//export storyteller_EffectControlled_CTor
func storyteller_EffectControlled_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_storyteller_EffectControlled(&storyteller.EffectControlled{}))
}

//export storyteller_EffectControlled_Desc
func storyteller_EffectControlled_Desc(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*storyteller.EffectControlled")
	if __err != nil {
		return handleFromPtr_game_EffectDescription(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(storyteller.EffectControlled{})).(*storyteller.EffectControlled).Desc()

	return handleFromPtr_game_EffectDescription(&cret)
}

//export storyteller_EffectControlled_Clone
func storyteller_EffectControlled_Clone(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*storyteller.EffectControlled")
	if __err != nil {
		return handleFromPtr_game_Effect(nil)
	}
	return handleFromPtr_game_Effect(gopyh.Embed(vifc, reflect.TypeOf(storyteller.EffectControlled{})).(*storyteller.EffectControlled).Clone())

}

//export storyteller_EffectControlled_HasTakenControl
func storyteller_EffectControlled_HasTakenControl(_handle CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*storyteller.EffectControlled")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(gopyh.Embed(vifc, reflect.TypeOf(storyteller.EffectControlled{})).(*storyteller.EffectControlled).HasTakenControl())

}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export storyteller_NewEffectCannotUse
func storyteller_NewEffectCannotUse(turnState CGoHandle, colour C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := storyteller.NewEffectCannotUse(*ptrFromHandle_game_TurnState(turnState), game.Colour(int(colour)))

	return handleFromPtr_storyteller_EffectCannotUse(&cret)
}

//export storyteller_NewEffectControlled
func storyteller_NewEffectControlled(turnState CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := storyteller.NewEffectControlled(*ptrFromHandle_game_TurnState(turnState))

	return handleFromPtr_storyteller_EffectControlled(&cret)
}

// ---- Functions ---

// ---- Package: structure ---

// ---- Types ---

// Converters for pointer handles for type: *structure.EffectIBoost
func ptrFromHandle_Ptr_structure_EffectIBoost(h CGoHandle) *structure.EffectIBoost {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*structure.EffectIBoost")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(structure.EffectIBoost{})).(*structure.EffectIBoost)
}
func handleFromPtr_Ptr_structure_EffectIBoost(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*structure.EffectIBoost", p))
}

// Converters for pointer handles for type: *structure.EffectLastChance
func ptrFromHandle_Ptr_structure_EffectLastChance(h CGoHandle) *structure.EffectLastChance {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*structure.EffectLastChance")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(structure.EffectLastChance{})).(*structure.EffectLastChance)
}
func handleFromPtr_Ptr_structure_EffectLastChance(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*structure.EffectLastChance", p))
}

// Converters for pointer handles for type: *structure.EffectSLayers
func ptrFromHandle_Ptr_structure_EffectSLayers(h CGoHandle) *structure.EffectSLayers {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*structure.EffectSLayers")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(structure.EffectSLayers{})).(*structure.EffectSLayers)
}
func handleFromPtr_Ptr_structure_EffectSLayers(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*structure.EffectSLayers", p))
}

// Converters for non-pointer handles for type: structure.EffectIBoost
func ptrFromHandle_structure_EffectIBoost(h CGoHandle) *structure.EffectIBoost {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "structure.EffectIBoost")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(structure.EffectIBoost{})).(*structure.EffectIBoost)
}
func handleFromPtr_structure_EffectIBoost(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("structure.EffectIBoost", p))
}

// Converters for non-pointer handles for type: structure.EffectLastChance
func ptrFromHandle_structure_EffectLastChance(h CGoHandle) *structure.EffectLastChance {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "structure.EffectLastChance")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(structure.EffectLastChance{})).(*structure.EffectLastChance)
}
func handleFromPtr_structure_EffectLastChance(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("structure.EffectLastChance", p))
}

// Converters for non-pointer handles for type: structure.EffectSLayers
func ptrFromHandle_structure_EffectSLayers(h CGoHandle) *structure.EffectSLayers {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "structure.EffectSLayers")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(structure.EffectSLayers{})).(*structure.EffectSLayers)
}
func handleFromPtr_structure_EffectSLayers(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("structure.EffectSLayers", p))
}

// ---- Global Variables: can only use functions to access ---
//
//export structure_CharacterStructure
func structure_CharacterStructure() CGoHandle {
	return handleFromPtr_Ptr_game_CharacterData(structure.CharacterStructure)
}

//export structure_Set_CharacterStructure
func structure_Set_CharacterStructure(val CGoHandle) {
	structure.CharacterStructure = ptrFromHandle_Ptr_game_CharacterData(val)
}

//export structure_EffectDescIBoost
func structure_EffectDescIBoost() CGoHandle {
	return handleFromPtr_game_EffectDescription(&structure.EffectDescIBoost)
}

//export structure_Set_EffectDescIBoost
func structure_Set_EffectDescIBoost(val CGoHandle) {
	structure.EffectDescIBoost = *ptrFromHandle_game_EffectDescription(val)
}

//export structure_EffectDescLastChance
func structure_EffectDescLastChance() CGoHandle {
	return handleFromPtr_game_EffectDescription(&structure.EffectDescLastChance)
}

//export structure_Set_EffectDescLastChance
func structure_Set_EffectDescLastChance(val CGoHandle) {
	structure.EffectDescLastChance = *ptrFromHandle_game_EffectDescription(val)
}

//export structure_EffectDescSLayers
func structure_EffectDescSLayers() CGoHandle {
	return handleFromPtr_game_EffectDescription(&structure.EffectDescSLayers)
}

//export structure_Set_EffectDescSLayers
func structure_Set_EffectDescSLayers(val CGoHandle) {
	structure.EffectDescSLayers = *ptrFromHandle_game_EffectDescription(val)
}

//export structure_SkillEShock
func structure_SkillEShock() CGoHandle {
	return handleFromPtr_Ptr_game_SkillData(structure.SkillEShock)
}

//export structure_Set_SkillEShock
func structure_Set_SkillEShock(val CGoHandle) {
	structure.SkillEShock = ptrFromHandle_Ptr_game_SkillData(val)
}

//export structure_SkillIBoost
func structure_SkillIBoost() CGoHandle {
	return handleFromPtr_Ptr_game_SkillData(structure.SkillIBoost)
}

//export structure_Set_SkillIBoost
func structure_Set_SkillIBoost(val CGoHandle) {
	structure.SkillIBoost = ptrFromHandle_Ptr_game_SkillData(val)
}

//export structure_SkillLastChance
func structure_SkillLastChance() CGoHandle {
	return handleFromPtr_Ptr_game_SkillData(structure.SkillLastChance)
}

//export structure_Set_SkillLastChance
func structure_Set_SkillLastChance(val CGoHandle) {
	structure.SkillLastChance = ptrFromHandle_Ptr_game_SkillData(val)
}

//export structure_SkillSLayers
func structure_SkillSLayers() CGoHandle {
	return handleFromPtr_Ptr_game_SkillData(structure.SkillSLayers)
}

//export structure_Set_SkillSLayers
func structure_Set_SkillSLayers(val CGoHandle) {
	structure.SkillSLayers = ptrFromHandle_Ptr_game_SkillData(val)
}

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: structure.EffectIBoost ---
//
//export structure_EffectIBoost_CTor
func structure_EffectIBoost_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_structure_EffectIBoost(&structure.EffectIBoost{}))
}

//export structure_EffectIBoost_Desc
func structure_EffectIBoost_Desc(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*structure.EffectIBoost")
	if __err != nil {
		return handleFromPtr_game_EffectDescription(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(structure.EffectIBoost{})).(*structure.EffectIBoost).Desc()

	return handleFromPtr_game_EffectDescription(&cret)
}

//export structure_EffectIBoost_Clone
func structure_EffectIBoost_Clone(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*structure.EffectIBoost")
	if __err != nil {
		return handleFromPtr_game_Effect(nil)
	}
	return handleFromPtr_game_Effect(gopyh.Embed(vifc, reflect.TypeOf(structure.EffectIBoost{})).(*structure.EffectIBoost).Clone())

}

//export structure_EffectIBoost_Amount
func structure_EffectIBoost_Amount(_handle CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*structure.EffectIBoost")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(gopyh.Embed(vifc, reflect.TypeOf(structure.EffectIBoost{})).(*structure.EffectIBoost).Amount())

}

//export structure_EffectIBoost_Increase
func structure_EffectIBoost_Increase(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*structure.EffectIBoost")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(structure.EffectIBoost{})).(*structure.EffectIBoost).Increase()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(structure.EffectIBoost{})).(*structure.EffectIBoost).Increase()
	}
}

// --- wrapping struct: structure.EffectLastChance ---
//
//export structure_EffectLastChance_CTor
func structure_EffectLastChance_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_structure_EffectLastChance(&structure.EffectLastChance{}))
}

//export structure_EffectLastChance_Desc
func structure_EffectLastChance_Desc(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*structure.EffectLastChance")
	if __err != nil {
		return handleFromPtr_game_EffectDescription(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(structure.EffectLastChance{})).(*structure.EffectLastChance).Desc()

	return handleFromPtr_game_EffectDescription(&cret)
}

//export structure_EffectLastChance_Clone
func structure_EffectLastChance_Clone(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*structure.EffectLastChance")
	if __err != nil {
		return handleFromPtr_game_Effect(nil)
	}
	return handleFromPtr_game_Effect(gopyh.Embed(vifc, reflect.TypeOf(structure.EffectLastChance{})).(*structure.EffectLastChance).Clone())

}

//export structure_EffectLastChance_OnTurnEnd
func structure_EffectLastChance_OnTurnEnd(_handle CGoHandle, c CGoHandle, opp CGoHandle, turnState CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*structure.EffectLastChance")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(structure.EffectLastChance{})).(*structure.EffectLastChance).OnTurnEnd(ptrFromHandle_Ptr_game_Character(c), ptrFromHandle_Ptr_game_Character(opp), *ptrFromHandle_game_TurnState(turnState))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(structure.EffectLastChance{})).(*structure.EffectLastChance).OnTurnEnd(ptrFromHandle_Ptr_game_Character(c), ptrFromHandle_Ptr_game_Character(opp), *ptrFromHandle_game_TurnState(turnState))
	}
}

// --- wrapping struct: structure.EffectSLayers ---
//
//export structure_EffectSLayers_CTor
func structure_EffectSLayers_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_structure_EffectSLayers(&structure.EffectSLayers{}))
}

//export structure_EffectSLayers_Desc
func structure_EffectSLayers_Desc(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*structure.EffectSLayers")
	if __err != nil {
		return handleFromPtr_game_EffectDescription(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(structure.EffectSLayers{})).(*structure.EffectSLayers).Desc()

	return handleFromPtr_game_EffectDescription(&cret)
}

//export structure_EffectSLayers_Clone
func structure_EffectSLayers_Clone(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*structure.EffectSLayers")
	if __err != nil {
		return handleFromPtr_game_Effect(nil)
	}
	return handleFromPtr_game_Effect(gopyh.Embed(vifc, reflect.TypeOf(structure.EffectSLayers{})).(*structure.EffectSLayers).Clone())

}

//export structure_EffectSLayers_Threshold
func structure_EffectSLayers_Threshold(_handle CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*structure.EffectSLayers")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(gopyh.Embed(vifc, reflect.TypeOf(structure.EffectSLayers{})).(*structure.EffectSLayers).Threshold())

}

//export structure_EffectSLayers_ModifyTakenDamage
func structure_EffectSLayers_ModifyTakenDamage(_handle CGoHandle, dmg C.longlong, colour C.longlong) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*structure.EffectSLayers")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(gopyh.Embed(vifc, reflect.TypeOf(structure.EffectSLayers{})).(*structure.EffectSLayers).ModifyTakenDamage(int(dmg), game.Colour(int(colour))))

}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export structure_NewEffectIBoost
func structure_NewEffectIBoost(amount C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_structure_EffectIBoost(structure.NewEffectIBoost(int(amount)))

}

//export structure_NewEffectLastChance
func structure_NewEffectLastChance(turnState CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := structure.NewEffectLastChance(*ptrFromHandle_game_TurnState(turnState))

	return handleFromPtr_structure_EffectLastChance(&cret)
}

//export structure_NewEffectSLayers
func structure_NewEffectSLayers(turnState CGoHandle, threshold C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := structure.NewEffectSLayers(*ptrFromHandle_game_TurnState(turnState), int(threshold))

	return handleFromPtr_structure_EffectSLayers(&cret)
}

// ---- Functions ---

// ---- Package: z89 ---

// ---- Types ---

// Converters for pointer handles for type: *z89.EffectUltimateSlow
func ptrFromHandle_Ptr_z89_EffectUltimateSlow(h CGoHandle) *z89.EffectUltimateSlow {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*z89.EffectUltimateSlow")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(z89.EffectUltimateSlow{})).(*z89.EffectUltimateSlow)
}
func handleFromPtr_Ptr_z89_EffectUltimateSlow(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*z89.EffectUltimateSlow", p))
}

// Converters for non-pointer handles for type: z89.EffectUltimateSlow
func ptrFromHandle_z89_EffectUltimateSlow(h CGoHandle) *z89.EffectUltimateSlow {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "z89.EffectUltimateSlow")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(z89.EffectUltimateSlow{})).(*z89.EffectUltimateSlow)
}
func handleFromPtr_z89_EffectUltimateSlow(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("z89.EffectUltimateSlow", p))
}

// ---- Global Variables: can only use functions to access ---
//
//export z89_CharacterZ89
func z89_CharacterZ89() CGoHandle {
	return handleFromPtr_Ptr_game_CharacterData(z89.CharacterZ89)
}

//export z89_Set_CharacterZ89
func z89_Set_CharacterZ89(val CGoHandle) {
	z89.CharacterZ89 = ptrFromHandle_Ptr_game_CharacterData(val)
}

//export z89_EffectDescUltimateSlow
func z89_EffectDescUltimateSlow() CGoHandle {
	return handleFromPtr_game_EffectDescription(&z89.EffectDescUltimateSlow)
}

//export z89_Set_EffectDescUltimateSlow
func z89_Set_EffectDescUltimateSlow(val CGoHandle) {
	z89.EffectDescUltimateSlow = *ptrFromHandle_game_EffectDescription(val)
}

//export z89_SkillDespondency
func z89_SkillDespondency() CGoHandle {
	return handleFromPtr_Ptr_game_SkillData(z89.SkillDespondency)
}

//export z89_Set_SkillDespondency
func z89_Set_SkillDespondency(val CGoHandle) {
	z89.SkillDespondency = ptrFromHandle_Ptr_game_SkillData(val)
}

//export z89_SkillGreenSphere
func z89_SkillGreenSphere() CGoHandle {
	return handleFromPtr_Ptr_game_SkillData(z89.SkillGreenSphere)
}

//export z89_Set_SkillGreenSphere
func z89_Set_SkillGreenSphere(val CGoHandle) {
	z89.SkillGreenSphere = ptrFromHandle_Ptr_game_SkillData(val)
}

//export z89_SkillIndifference
func z89_SkillIndifference() CGoHandle {
	return handleFromPtr_Ptr_game_SkillData(z89.SkillIndifference)
}

//export z89_Set_SkillIndifference
func z89_Set_SkillIndifference(val CGoHandle) {
	z89.SkillIndifference = ptrFromHandle_Ptr_game_SkillData(val)
}

//export z89_SkillScarcity
func z89_SkillScarcity() CGoHandle {
	return handleFromPtr_Ptr_game_SkillData(z89.SkillScarcity)
}

//export z89_Set_SkillScarcity
func z89_Set_SkillScarcity(val CGoHandle) {
	z89.SkillScarcity = ptrFromHandle_Ptr_game_SkillData(val)
}

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: z89.EffectUltimateSlow ---
//
//export z89_EffectUltimateSlow_CTor
func z89_EffectUltimateSlow_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_z89_EffectUltimateSlow(&z89.EffectUltimateSlow{}))
}

//export z89_EffectUltimateSlow_Desc
func z89_EffectUltimateSlow_Desc(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*z89.EffectUltimateSlow")
	if __err != nil {
		return handleFromPtr_game_EffectDescription(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(z89.EffectUltimateSlow{})).(*z89.EffectUltimateSlow).Desc()

	return handleFromPtr_game_EffectDescription(&cret)
}

//export z89_EffectUltimateSlow_Clone
func z89_EffectUltimateSlow_Clone(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*z89.EffectUltimateSlow")
	if __err != nil {
		return handleFromPtr_game_Effect(nil)
	}
	return handleFromPtr_game_Effect(gopyh.Embed(vifc, reflect.TypeOf(z89.EffectUltimateSlow{})).(*z89.EffectUltimateSlow).Clone())

}

//export z89_EffectUltimateSlow_Amount
func z89_EffectUltimateSlow_Amount(_handle CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*z89.EffectUltimateSlow")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(gopyh.Embed(vifc, reflect.TypeOf(z89.EffectUltimateSlow{})).(*z89.EffectUltimateSlow).Amount())

}

//export z89_EffectUltimateSlow_Increase
func z89_EffectUltimateSlow_Increase(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*z89.EffectUltimateSlow")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(z89.EffectUltimateSlow{})).(*z89.EffectUltimateSlow).Increase()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(z89.EffectUltimateSlow{})).(*z89.EffectUltimateSlow).Increase()
	}
}

//export z89_EffectUltimateSlow_ModifySkillUnlockTurn
func z89_EffectUltimateSlow_ModifySkillUnlockTurn(_handle CGoHandle, s CGoHandle, unlockTurn C.longlong) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*z89.EffectUltimateSlow")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(gopyh.Embed(vifc, reflect.TypeOf(z89.EffectUltimateSlow{})).(*z89.EffectUltimateSlow).ModifySkillUnlockTurn(ptrFromHandle_Ptr_game_Skill(s), int(unlockTurn)))

}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export z89_NewEffectUltimateSlow
func z89_NewEffectUltimateSlow() CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_z89_EffectUltimateSlow(z89.NewEffectUltimateSlow())

}

// ---- Functions ---

// ---- Package: common ---

// ---- Types ---

// Converters for pointer handles for type: *common.Collectible
func ptrFromHandle_Ptr_common_Collectible(h CGoHandle) *common.Collectible {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*common.Collectible")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(common.Collectible{})).(*common.Collectible)
}
func handleFromPtr_Ptr_common_Collectible(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*common.Collectible", p))
}

// Converters for pointer handles for type: *common.DurationExpirable
func ptrFromHandle_Ptr_common_DurationExpirable(h CGoHandle) *common.DurationExpirable {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*common.DurationExpirable")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(common.DurationExpirable{})).(*common.DurationExpirable)
}
func handleFromPtr_Ptr_common_DurationExpirable(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*common.DurationExpirable", p))
}

// Converters for non-pointer handles for type: common.Collectible
func ptrFromHandle_common_Collectible(h CGoHandle) *common.Collectible {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "common.Collectible")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(common.Collectible{})).(*common.Collectible)
}
func handleFromPtr_common_Collectible(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("common.Collectible", p))
}

// Converters for non-pointer handles for type: common.DurationExpirable
func ptrFromHandle_common_DurationExpirable(h CGoHandle) *common.DurationExpirable {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "common.DurationExpirable")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(common.DurationExpirable{})).(*common.DurationExpirable)
}
func handleFromPtr_common_DurationExpirable(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("common.DurationExpirable", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: common.Collectible ---
//
//export common_Collectible_CTor
func common_Collectible_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_common_Collectible(&common.Collectible{}))
}

//export common_Collectible_Amount
func common_Collectible_Amount(_handle CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*common.Collectible")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(gopyh.Embed(vifc, reflect.TypeOf(common.Collectible{})).(*common.Collectible).Amount())

}

//export common_Collectible_Increase
func common_Collectible_Increase(_handle CGoHandle, amount C.longlong, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*common.Collectible")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(common.Collectible{})).(*common.Collectible).Increase(int(amount))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(common.Collectible{})).(*common.Collectible).Increase(int(amount))
	}
}

//export common_Collectible_Decrease
func common_Collectible_Decrease(_handle CGoHandle, amount C.longlong, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*common.Collectible")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(common.Collectible{})).(*common.Collectible).Decrease(int(amount))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(common.Collectible{})).(*common.Collectible).Decrease(int(amount))
	}
}

//export common_Collectible_HasExpired
func common_Collectible_HasExpired(_handle CGoHandle, turnState CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*common.Collectible")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(gopyh.Embed(vifc, reflect.TypeOf(common.Collectible{})).(*common.Collectible).HasExpired(*ptrFromHandle_game_TurnState(turnState)))

}

// --- wrapping struct: common.DurationExpirable ---
//
//export common_DurationExpirable_CTor
func common_DurationExpirable_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_common_DurationExpirable(&common.DurationExpirable{}))
}

//export common_DurationExpirable_TurnsLeft
func common_DurationExpirable_TurnsLeft(_handle CGoHandle, turnState CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*common.DurationExpirable")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(gopyh.Embed(vifc, reflect.TypeOf(common.DurationExpirable{})).(*common.DurationExpirable).TurnsLeft(*ptrFromHandle_game_TurnState(turnState)))

}

//export common_DurationExpirable_HasExpired
func common_DurationExpirable_HasExpired(_handle CGoHandle, turnState CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*common.DurationExpirable")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(gopyh.Embed(vifc, reflect.TypeOf(common.DurationExpirable{})).(*common.DurationExpirable).HasExpired(*ptrFromHandle_game_TurnState(turnState)))

}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export common_NewCollectible
func common_NewCollectible(amount C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_common_Collectible(common.NewCollectible(int(amount)))

}

//export common_NewDurationExpirable
func common_NewDurationExpirable(expCtx CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := common.NewDurationExpirable(*ptrFromHandle_game_TurnState(expCtx))

	return handleFromPtr_common_DurationExpirable(&cret)
}

// ---- Functions ---

// ---- Package: gametest ---

// ---- Types ---

// Converters for pointer handles for type: *gametest.EffectExpirable
func ptrFromHandle_Ptr_gametest_EffectExpirable(h CGoHandle) *gametest.EffectExpirable {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*gametest.EffectExpirable")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gametest.EffectExpirable{})).(*gametest.EffectExpirable)
}
func handleFromPtr_Ptr_gametest_EffectExpirable(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*gametest.EffectExpirable", p))
}

// Converters for non-pointer handles for type: gametest.EffectExpirable
func ptrFromHandle_gametest_EffectExpirable(h CGoHandle) *gametest.EffectExpirable {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "gametest.EffectExpirable")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gametest.EffectExpirable{})).(*gametest.EffectExpirable)
}
func handleFromPtr_gametest_EffectExpirable(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("gametest.EffectExpirable", p))
}

// ---- Global Variables: can only use functions to access ---
//
//export gametest_EffectDescExpirable
func gametest_EffectDescExpirable() CGoHandle {
	return handleFromPtr_game_EffectDescription(&gametest.EffectDescExpirable)
}

//export gametest_Set_EffectDescExpirable
func gametest_Set_EffectDescExpirable(val CGoHandle) {
	gametest.EffectDescExpirable = *ptrFromHandle_game_EffectDescription(val)
}

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: gametest.EffectExpirable ---
//
//export gametest_EffectExpirable_CTor
func gametest_EffectExpirable_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_gametest_EffectExpirable(&gametest.EffectExpirable{}))
}

//export gametest_EffectExpirable_Desc
func gametest_EffectExpirable_Desc(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gametest.EffectExpirable")
	if __err != nil {
		return handleFromPtr_game_EffectDescription(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(gametest.EffectExpirable{})).(*gametest.EffectExpirable).Desc()

	return handleFromPtr_game_EffectDescription(&cret)
}

//export gametest_EffectExpirable_Clone
func gametest_EffectExpirable_Clone(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gametest.EffectExpirable")
	if __err != nil {
		return handleFromPtr_game_Effect(nil)
	}
	return handleFromPtr_game_Effect(gopyh.Embed(vifc, reflect.TypeOf(gametest.EffectExpirable{})).(*gametest.EffectExpirable).Clone())

}

//export gametest_EffectExpirable_Expire
func gametest_EffectExpirable_Expire(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gametest.EffectExpirable")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(gametest.EffectExpirable{})).(*gametest.EffectExpirable).Expire()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(gametest.EffectExpirable{})).(*gametest.EffectExpirable).Expire()
	}
}

//export gametest_EffectExpirable_HasExpired
func gametest_EffectExpirable_HasExpired(_handle CGoHandle, turnState CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gametest.EffectExpirable")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(gopyh.Embed(vifc, reflect.TypeOf(gametest.EffectExpirable{})).(*gametest.EffectExpirable).HasExpired(*ptrFromHandle_game_TurnState(turnState)))

}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export gametest_NewEffectExpirable
func gametest_NewEffectExpirable(expired C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_gametest_EffectExpirable(gametest.NewEffectExpirable(boolPyToGo(expired)))

}

// ---- Functions ---

// ---- Package: match ---

// ---- Types ---

// Converters for pointer handles for type: *match.CharacterPlayer
func ptrFromHandle_Ptr_match_CharacterPlayer(h CGoHandle) *match.CharacterPlayer {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*match.CharacterPlayer")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(match.CharacterPlayer{})).(*match.CharacterPlayer)
}
func handleFromPtr_Ptr_match_CharacterPlayer(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*match.CharacterPlayer", p))
}

// Converters for pointer handles for type: *match.GameState
func ptrFromHandle_Ptr_match_GameState(h CGoHandle) *match.GameState {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*match.GameState")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(match.GameState{})).(*match.GameState)
}
func handleFromPtr_Ptr_match_GameState(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*match.GameState", p))
}

// Converters for pointer handles for type: *match.Match
func ptrFromHandle_Ptr_match_Match(h CGoHandle) *match.Match {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*match.Match")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(match.Match{})).(*match.Match)
}
func handleFromPtr_Ptr_match_Match(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*match.Match", p))
}

// Converters for implicit pointer handles for type: []game.TurnState
func ptrFromHandle_Slice_game_TurnState(h CGoHandle) *[]game.TurnState {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]game.TurnState")
	if p == nil {
		return nil
	}
	return p.(*[]game.TurnState)
}
func deptrFromHandle_Slice_game_TurnState(h CGoHandle) []game.TurnState {
	p := ptrFromHandle_Slice_game_TurnState(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_game_TurnState(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]game.TurnState", p))
}

// --- wrapping slice: []game.TurnState ---
//
//export Slice_game_TurnState_CTor
func Slice_game_TurnState_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_game_TurnState(&[]game.TurnState{}))
}

//export Slice_game_TurnState_len
func Slice_game_TurnState_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_game_TurnState(handle))
}

//export Slice_game_TurnState_elem
func Slice_game_TurnState_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_game_TurnState(handle)
	return handleFromPtr_game_TurnState(&(s[_idx]))
}

//export Slice_game_TurnState_subslice
func Slice_game_TurnState_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_game_TurnState(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_game_TurnState(&ss))
}

//export Slice_game_TurnState_set
func Slice_game_TurnState_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_game_TurnState(handle)
	s[_idx] = *ptrFromHandle_game_TurnState(_vl)
}

//export Slice_game_TurnState_append
func Slice_game_TurnState_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_game_TurnState(handle)
	*s = append(*s, *ptrFromHandle_game_TurnState(_vl))
}

// Converters for non-pointer handles for type: match.CharacterPlayer
func ptrFromHandle_match_CharacterPlayer(h CGoHandle) *match.CharacterPlayer {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "match.CharacterPlayer")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(match.CharacterPlayer{})).(*match.CharacterPlayer)
}
func handleFromPtr_match_CharacterPlayer(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("match.CharacterPlayer", p))
}

// Converters for non-pointer handles for type: match.GameState
func ptrFromHandle_match_GameState(h CGoHandle) *match.GameState {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "match.GameState")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(match.GameState{})).(*match.GameState)
}
func handleFromPtr_match_GameState(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("match.GameState", p))
}

// Converters for non-pointer handles for type: match.Match
func ptrFromHandle_match_Match(h CGoHandle) *match.Match {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "match.Match")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(match.Match{})).(*match.Match)
}
func handleFromPtr_match_Match(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("match.Match", p))
}

// Converters for pointer handles for type: match.Player
func ptrFromHandle_match_Player(h CGoHandle) match.Player {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "match.Player")
	if p == nil {
		return nil
	}
	return p.(match.Player)
}
func handleFromPtr_match_Player(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("match.Player", p))
}

// Converters for implicit pointer handles for type: match.SkillLog
func ptrFromHandle_match_SkillLog(h CGoHandle) *match.SkillLog {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "match.SkillLog")
	if p == nil {
		return nil
	}
	return p.(*match.SkillLog)
}
func deptrFromHandle_match_SkillLog(h CGoHandle) match.SkillLog {
	p := ptrFromHandle_match_SkillLog(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_match_SkillLog(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("match.SkillLog", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

//export match_Player_RequestSkill
func match_Player_RequestSkill(_handle CGoHandle, ctx CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "match.Player")
	if __err != nil {
		return C.longlong(0)
	}
	cret, __err := vifc.(match.Player).RequestSkill(ptrFromHandle_context_Context(ctx))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.longlong(0)
	}
	return C.longlong(cret)
}

//export match_Player_SendEnd
func match_Player_SendEnd(_handle CGoHandle, ctx CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "match.Player")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(match.Player).SendEnd(ptrFromHandle_context_Context(ctx))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export match_Player_SendError
func match_Player_SendError(_handle CGoHandle, ctx CGoHandle, err *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "match.Player")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(match.Player).SendError(ptrFromHandle_context_Context(ctx), errors.New(C.GoString(err)))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export match_Player_SendState
func match_Player_SendState(_handle CGoHandle, ctx CGoHandle, state CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "match.Player")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(match.Player).SendState(ptrFromHandle_context_Context(ctx), *ptrFromHandle_match_GameState(state))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// ---- Structs ---

// --- wrapping struct: match.CharacterPlayer ---
//
//export match_CharacterPlayer_CTor
func match_CharacterPlayer_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_match_CharacterPlayer(&match.CharacterPlayer{}))
}

//export match_CharacterPlayer_Character_Get
func match_CharacterPlayer_Character_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_match_CharacterPlayer(handle)
	return handleFromPtr_Ptr_game_Character(op.Character)
}

//export match_CharacterPlayer_Character_Set
func match_CharacterPlayer_Character_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_match_CharacterPlayer(handle)
	op.Character = ptrFromHandle_Ptr_game_Character(val)
}

//export match_CharacterPlayer_Player_Get
func match_CharacterPlayer_Player_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_match_CharacterPlayer(handle)
	return handleFromPtr_match_Player(op.Player)
}

//export match_CharacterPlayer_Player_Set
func match_CharacterPlayer_Player_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_match_CharacterPlayer(handle)
	op.Player = ptrFromHandle_match_Player(val)
}

// --- wrapping struct: match.GameState ---
//
//export match_GameState_CTor
func match_GameState_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_match_GameState(&match.GameState{}))
}

//export match_GameState_Character_Get
func match_GameState_Character_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_match_GameState(handle)
	return handleFromPtr_Ptr_game_Character(op.Character)
}

//export match_GameState_Character_Set
func match_GameState_Character_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_match_GameState(handle)
	op.Character = ptrFromHandle_Ptr_game_Character(val)
}

//export match_GameState_Opponent_Get
func match_GameState_Opponent_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_match_GameState(handle)
	return handleFromPtr_Ptr_game_Character(op.Opponent)
}

//export match_GameState_Opponent_Set
func match_GameState_Opponent_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_match_GameState(handle)
	op.Opponent = ptrFromHandle_Ptr_game_Character(val)
}

//export match_GameState_TurnState_Get
func match_GameState_TurnState_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_match_GameState(handle)
	return handleFromPtr_game_TurnState(&op.TurnState)
}

//export match_GameState_TurnState_Set
func match_GameState_TurnState_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_match_GameState(handle)
	op.TurnState = *ptrFromHandle_game_TurnState(val)
}

//export match_GameState_SkillsLeft_Get
func match_GameState_SkillsLeft_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_match_GameState(handle)
	return C.longlong(op.SkillsLeft)
}

//export match_GameState_SkillsLeft_Set
func match_GameState_SkillsLeft_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_match_GameState(handle)
	op.SkillsLeft = int(val)
}

//export match_GameState_SkillLog_Get
func match_GameState_SkillLog_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_match_GameState(handle)
	return handleFromPtr_match_SkillLog(&op.SkillLog)
}

//export match_GameState_SkillLog_Set
func match_GameState_SkillLog_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_match_GameState(handle)
	op.SkillLog = deptrFromHandle_match_SkillLog(val)
}

//export match_GameState_PlayerTurn_Get
func match_GameState_PlayerTurn_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_match_GameState(handle)
	return boolGoToPy(op.PlayerTurn)
}

//export match_GameState_PlayerTurn_Set
func match_GameState_PlayerTurn_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_match_GameState(handle)
	op.PlayerTurn = boolPyToGo(val)
}

//export match_GameState_AsOpp_Get
func match_GameState_AsOpp_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_match_GameState(handle)
	return boolGoToPy(op.AsOpp)
}

//export match_GameState_AsOpp_Set
func match_GameState_AsOpp_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_match_GameState(handle)
	op.AsOpp = boolPyToGo(val)
}

//export match_GameState_IsEnd
func match_GameState_IsEnd(_handle CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*match.GameState")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(gopyh.Embed(vifc, reflect.TypeOf(match.GameState{})).(*match.GameState).IsEnd())

}

//export match_GameState_Clone
func match_GameState_Clone(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*match.GameState")
	if __err != nil {
		return handleFromPtr_match_GameState(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(match.GameState{})).(*match.GameState).Clone()

	return handleFromPtr_match_GameState(&cret)
}

//export match_GameState_CloneWithSkill
func match_GameState_CloneWithSkill(_handle CGoHandle, i C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*match.GameState")
	if __err != nil {
		return handleFromPtr_match_GameState(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(match.GameState{})).(*match.GameState).CloneWithSkill(int(i))

	return handleFromPtr_match_GameState(&cret)
}

// --- wrapping struct: match.Match ---
//
//export match_Match_CTor
func match_Match_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_match_Match(&match.Match{}))
}

//export match_Match_Run
func match_Match_Run(_handle CGoHandle, ctx CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*match.Match")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(match.Match{})).(*match.Match).Run(ptrFromHandle_context_Context(ctx))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export match_Match_Result
func match_Match_Result(_handle CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*match.Match")
	if __err != nil {
		return C.longlong(int(0))
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(match.Match{})).(*match.Match).Result()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.longlong(int(0))
	}
	return C.longlong(int(cret))
}

// ---- Slices ---

// ---- Maps ---

// --- wrapping map: match.SkillLog ---
//
//export match_SkillLog_CTor
func match_SkillLog_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_match_SkillLog(&match.SkillLog{}))
}

//export match_SkillLog_len
func match_SkillLog_len(handle CGoHandle) int {
	return len(deptrFromHandle_match_SkillLog(handle))
}

//export match_SkillLog_elem
func match_SkillLog_elem(handle CGoHandle, _ky CGoHandle) CGoHandle {
	s := deptrFromHandle_match_SkillLog(handle)
	v, ok := s[*ptrFromHandle_game_TurnState(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Slice_int(&v)
}

//export match_SkillLog_contains
func match_SkillLog_contains(handle CGoHandle, _ky CGoHandle) C.char {
	s := deptrFromHandle_match_SkillLog(handle)
	_, ok := s[*ptrFromHandle_game_TurnState(_ky)]
	return boolGoToPy(ok)
}

//export match_SkillLog_set
func match_SkillLog_set(handle CGoHandle, _ky CGoHandle, _vl CGoHandle) {
	s := deptrFromHandle_match_SkillLog(handle)
	s[*ptrFromHandle_game_TurnState(_ky)] = deptrFromHandle_Slice_int(_vl)
}

//export match_SkillLog_delete
func match_SkillLog_delete(handle CGoHandle, _ky CGoHandle) {
	s := deptrFromHandle_match_SkillLog(handle)
	delete(s, *ptrFromHandle_game_TurnState(_ky))
}

//export match_SkillLog_keys
func match_SkillLog_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_match_SkillLog(handle)
	kys := make([]game.TurnState, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_game_TurnState(&kys)
}

//export match_SkillLog_Clone
func match_SkillLog_Clone(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*match.SkillLog")
	if __err != nil {
		return handleFromPtr_match_SkillLog(nil)
	}
	cret := vifc.(*match.SkillLog).Clone()

	return handleFromPtr_match_SkillLog(&cret)
}

//export match_SkillLog_Append
func match_SkillLog_Append(_handle CGoHandle, turn CGoHandle, skill C.longlong, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*match.SkillLog")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(*match.SkillLog).Append(*ptrFromHandle_game_TurnState(turn), int(skill))
	} else {
		vifc.(*match.SkillLog).Append(*ptrFromHandle_game_TurnState(turn), int(skill))
	}
}

// ---- Constructors ---

//export match_New
func match_New(p1 CGoHandle, p2 CGoHandle, invertedOrder C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_match_Match(match.New(*ptrFromHandle_match_CharacterPlayer(p1), *ptrFromHandle_match_CharacterPlayer(p2), boolPyToGo(invertedOrder)))

}

// ---- Functions ---

// ---- Package: bot ---

// ---- Types ---

// Converters for pointer handles for type: *bot.RandomBot
func ptrFromHandle_Ptr_bot_RandomBot(h CGoHandle) *bot.RandomBot {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*bot.RandomBot")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(bot.RandomBot{})).(*bot.RandomBot)
}
func handleFromPtr_Ptr_bot_RandomBot(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*bot.RandomBot", p))
}

// Converters for pointer handles for type: *bot.RevAdapter
func ptrFromHandle_Ptr_bot_RevAdapter(h CGoHandle) *bot.RevAdapter {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*bot.RevAdapter")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(bot.RevAdapter{})).(*bot.RevAdapter)
}
func handleFromPtr_Ptr_bot_RevAdapter(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*bot.RevAdapter", p))
}

// Converters for non-pointer handles for type: bot.RandomBot
func ptrFromHandle_bot_RandomBot(h CGoHandle) *bot.RandomBot {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "bot.RandomBot")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(bot.RandomBot{})).(*bot.RandomBot)
}
func handleFromPtr_bot_RandomBot(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("bot.RandomBot", p))
}

// Converters for non-pointer handles for type: bot.RevAdapter
func ptrFromHandle_bot_RevAdapter(h CGoHandle) *bot.RevAdapter {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "bot.RevAdapter")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(bot.RevAdapter{})).(*bot.RevAdapter)
}
func handleFromPtr_bot_RevAdapter(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("bot.RevAdapter", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: bot.RevAdapter ---
//
//export bot_RevAdapter_CTor
func bot_RevAdapter_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_bot_RevAdapter(&bot.RevAdapter{}))
}

//export bot_RevAdapter_GetStateInit
func bot_RevAdapter_GetStateInit(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*bot.RevAdapter")
	if __err != nil {
		return handleFromPtr_match_GameState(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(bot.RevAdapter{})).(*bot.RevAdapter).GetStateInit()

	return handleFromPtr_match_GameState(&cret)
}

//export bot_RevAdapter_GetState
func bot_RevAdapter_GetState(_handle CGoHandle, skill C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*bot.RevAdapter")
	if __err != nil {
		return handleFromPtr_match_GameState(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(bot.RevAdapter{})).(*bot.RevAdapter).GetState(int(skill))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_match_GameState(nil)
	}
	return handleFromPtr_match_GameState(&cret)
}

//export bot_RevAdapter_SendState
func bot_RevAdapter_SendState(_handle CGoHandle, ctx CGoHandle, state CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*bot.RevAdapter")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(bot.RevAdapter{})).(*bot.RevAdapter).SendState(ptrFromHandle_context_Context(ctx), *ptrFromHandle_match_GameState(state))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export bot_RevAdapter_SendError
func bot_RevAdapter_SendError(_handle CGoHandle, ctx CGoHandle, err *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*bot.RevAdapter")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(bot.RevAdapter{})).(*bot.RevAdapter).SendError(ptrFromHandle_context_Context(ctx), errors.New(C.GoString(err)))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export bot_RevAdapter_SendEnd
func bot_RevAdapter_SendEnd(_handle CGoHandle, ctx CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*bot.RevAdapter")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(bot.RevAdapter{})).(*bot.RevAdapter).SendEnd(ptrFromHandle_context_Context(ctx))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export bot_RevAdapter_RequestSkill
func bot_RevAdapter_RequestSkill(_handle CGoHandle, ctx CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*bot.RevAdapter")
	if __err != nil {
		return C.longlong(0)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(bot.RevAdapter{})).(*bot.RevAdapter).RequestSkill(ptrFromHandle_context_Context(ctx))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.longlong(0)
	}
	return C.longlong(cret)
}

// --- wrapping struct: bot.RandomBot ---
//
//export bot_RandomBot_CTor
func bot_RandomBot_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_bot_RandomBot(&bot.RandomBot{}))
}

//export bot_RandomBot_SendState
func bot_RandomBot_SendState(_handle CGoHandle, ctx CGoHandle, state CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*bot.RandomBot")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(bot.RandomBot{})).(*bot.RandomBot).SendState(ptrFromHandle_context_Context(ctx), *ptrFromHandle_match_GameState(state))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export bot_RandomBot_SendError
func bot_RandomBot_SendError(_handle CGoHandle, ctx CGoHandle, err *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*bot.RandomBot")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(bot.RandomBot{})).(*bot.RandomBot).SendError(ptrFromHandle_context_Context(ctx), errors.New(C.GoString(err)))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export bot_RandomBot_SendEnd
func bot_RandomBot_SendEnd(_handle CGoHandle, ctx CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*bot.RandomBot")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(bot.RandomBot{})).(*bot.RandomBot).SendEnd(ptrFromHandle_context_Context(ctx))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export bot_RandomBot_RequestSkill
func bot_RandomBot_RequestSkill(_handle CGoHandle, ctx CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*bot.RandomBot")
	if __err != nil {
		return C.longlong(0)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(bot.RandomBot{})).(*bot.RandomBot).RequestSkill(ptrFromHandle_context_Context(ctx))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.longlong(0)
	}
	return C.longlong(cret)
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export bot_NewAdapter
func bot_NewAdapter() CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_bot_RevAdapter(bot.NewAdapter())

}

// ---- Functions ---

// ---- Package: minimax ---

// ---- Types ---

// Converters for pointer handles for type: *minimax.Bot
func ptrFromHandle_Ptr_minimax_Bot(h CGoHandle) *minimax.Bot {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*minimax.Bot")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(minimax.Bot{})).(*minimax.Bot)
}
func handleFromPtr_Ptr_minimax_Bot(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*minimax.Bot", p))
}

// Converters for pointer handles for type: *minimax.Entry
func ptrFromHandle_Ptr_minimax_Entry(h CGoHandle) *minimax.Entry {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*minimax.Entry")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(minimax.Entry{})).(*minimax.Entry)
}
func handleFromPtr_Ptr_minimax_Entry(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*minimax.Entry", p))
}

// Converters for pointer handles for type: *minimax.Result
func ptrFromHandle_Ptr_minimax_Result(h CGoHandle) *minimax.Result {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*minimax.Result")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(minimax.Result{})).(*minimax.Result)
}
func handleFromPtr_Ptr_minimax_Result(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*minimax.Result", p))
}

// Converters for pointer handles for type: *minimax.Runner
func ptrFromHandle_Ptr_minimax_Runner(h CGoHandle) *minimax.Runner {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*minimax.Runner")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(minimax.Runner{})).(*minimax.Runner)
}
func handleFromPtr_Ptr_minimax_Runner(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*minimax.Runner", p))
}

// Converters for implicit pointer handles for type: []minimax.Entry
func ptrFromHandle_Slice_minimax_Entry(h CGoHandle) *[]minimax.Entry {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]minimax.Entry")
	if p == nil {
		return nil
	}
	return p.(*[]minimax.Entry)
}
func deptrFromHandle_Slice_minimax_Entry(h CGoHandle) []minimax.Entry {
	p := ptrFromHandle_Slice_minimax_Entry(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_minimax_Entry(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]minimax.Entry", p))
}

// --- wrapping slice: []minimax.Entry ---
//
//export Slice_minimax_Entry_CTor
func Slice_minimax_Entry_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_minimax_Entry(&[]minimax.Entry{}))
}

//export Slice_minimax_Entry_len
func Slice_minimax_Entry_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_minimax_Entry(handle))
}

//export Slice_minimax_Entry_elem
func Slice_minimax_Entry_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_minimax_Entry(handle)
	return handleFromPtr_minimax_Entry(&(s[_idx]))
}

//export Slice_minimax_Entry_subslice
func Slice_minimax_Entry_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_minimax_Entry(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_minimax_Entry(&ss))
}

//export Slice_minimax_Entry_set
func Slice_minimax_Entry_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_minimax_Entry(handle)
	s[_idx] = *ptrFromHandle_minimax_Entry(_vl)
}

//export Slice_minimax_Entry_append
func Slice_minimax_Entry_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_minimax_Entry(handle)
	*s = append(*s, *ptrFromHandle_minimax_Entry(_vl))
}

// Converters for non-pointer handles for type: minimax.Bot
func ptrFromHandle_minimax_Bot(h CGoHandle) *minimax.Bot {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "minimax.Bot")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(minimax.Bot{})).(*minimax.Bot)
}
func handleFromPtr_minimax_Bot(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("minimax.Bot", p))
}

// Converters for non-pointer handles for type: minimax.Entry
func ptrFromHandle_minimax_Entry(h CGoHandle) *minimax.Entry {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "minimax.Entry")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(minimax.Entry{})).(*minimax.Entry)
}
func handleFromPtr_minimax_Entry(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("minimax.Entry", p))
}

// Converters for non-pointer handles for type: minimax.Result
func ptrFromHandle_minimax_Result(h CGoHandle) *minimax.Result {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "minimax.Result")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(minimax.Result{})).(*minimax.Result)
}
func handleFromPtr_minimax_Result(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("minimax.Result", p))
}

// Converters for non-pointer handles for type: minimax.Runner
func ptrFromHandle_minimax_Runner(h CGoHandle) *minimax.Runner {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "minimax.Runner")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(minimax.Runner{})).(*minimax.Runner)
}
func handleFromPtr_minimax_Runner(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("minimax.Runner", p))
}

// ---- Global Variables: can only use functions to access ---
//
//export minimax_MemOptConcurrentRunner
func minimax_MemOptConcurrentRunner() CGoHandle {
	return handleFromPtr_minimax_Runner(&minimax.MemOptConcurrentRunner)
}

//export minimax_Set_MemOptConcurrentRunner
func minimax_Set_MemOptConcurrentRunner(val CGoHandle) {
	minimax.MemOptConcurrentRunner = *ptrFromHandle_minimax_Runner(val)
}

//export minimax_SequentialRunner
func minimax_SequentialRunner() CGoHandle {
	return handleFromPtr_minimax_Runner(&minimax.SequentialRunner)
}

//export minimax_Set_SequentialRunner
func minimax_Set_SequentialRunner(val CGoHandle) {
	minimax.SequentialRunner = *ptrFromHandle_minimax_Runner(val)
}

//export minimax_TimeOptConcurrentRunner
func minimax_TimeOptConcurrentRunner() CGoHandle {
	return handleFromPtr_minimax_Runner(&minimax.TimeOptConcurrentRunner)
}

//export minimax_Set_TimeOptConcurrentRunner
func minimax_Set_TimeOptConcurrentRunner(val CGoHandle) {
	minimax.TimeOptConcurrentRunner = *ptrFromHandle_minimax_Runner(val)
}

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: minimax.Bot ---
//
//export minimax_Bot_CTor
func minimax_Bot_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_minimax_Bot(&minimax.Bot{}))
}

//export minimax_Bot_SendState
func minimax_Bot_SendState(_handle CGoHandle, ctx CGoHandle, state CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*minimax.Bot")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(minimax.Bot{})).(*minimax.Bot).SendState(ptrFromHandle_context_Context(ctx), *ptrFromHandle_match_GameState(state))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export minimax_Bot_SendError
func minimax_Bot_SendError(_handle CGoHandle, ctx CGoHandle, err *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*minimax.Bot")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(minimax.Bot{})).(*minimax.Bot).SendError(ptrFromHandle_context_Context(ctx), errors.New(C.GoString(err)))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export minimax_Bot_SendEnd
func minimax_Bot_SendEnd(_handle CGoHandle, ctx CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*minimax.Bot")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(minimax.Bot{})).(*minimax.Bot).SendEnd(ptrFromHandle_context_Context(ctx))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export minimax_Bot_RequestSkill
func minimax_Bot_RequestSkill(_handle CGoHandle, ctx CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*minimax.Bot")
	if __err != nil {
		return C.longlong(0)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(minimax.Bot{})).(*minimax.Bot).RequestSkill(ptrFromHandle_context_Context(ctx))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.longlong(0)
	}
	return C.longlong(cret)
}

// --- wrapping struct: minimax.Entry ---
//
//export minimax_Entry_CTor
func minimax_Entry_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_minimax_Entry(&minimax.Entry{}))
}

//export minimax_Entry_State_Get
func minimax_Entry_State_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_minimax_Entry(handle)
	return handleFromPtr_match_GameState(&op.State)
}

//export minimax_Entry_State_Set
func minimax_Entry_State_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_minimax_Entry(handle)
	op.State = *ptrFromHandle_match_GameState(val)
}

//export minimax_Entry_Result_Get
func minimax_Entry_Result_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_minimax_Entry(handle)
	return handleFromPtr_match_SkillLog(&op.Result)
}

//export minimax_Entry_Result_Set
func minimax_Entry_Result_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_minimax_Entry(handle)
	op.Result = deptrFromHandle_match_SkillLog(val)
}

// --- wrapping struct: minimax.Result ---
//
//export minimax_Result_CTor
func minimax_Result_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_minimax_Result(&minimax.Result{}))
}

//export minimax_Result_Score_Get
func minimax_Result_Score_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_minimax_Result(handle)
	return C.longlong(op.Score)
}

//export minimax_Result_Score_Set
func minimax_Result_Score_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_minimax_Result(handle)
	op.Score = int(val)
}

//export minimax_Result_Strategy_Get
func minimax_Result_Strategy_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_minimax_Result(handle)
	return handleFromPtr_match_SkillLog(&op.Strategy)
}

//export minimax_Result_Strategy_Set
func minimax_Result_Strategy_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_minimax_Result(handle)
	op.Strategy = deptrFromHandle_match_SkillLog(val)
}

//export minimax_Result_Entries_Get
func minimax_Result_Entries_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_minimax_Result(handle)
	return handleFromPtr_Slice_minimax_Entry(&op.Entries)
}

//export minimax_Result_Entries_Set
func minimax_Result_Entries_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_minimax_Result(handle)
	op.Entries = deptrFromHandle_Slice_minimax_Entry(val)
}

// --- wrapping struct: minimax.Runner ---
//
//export minimax_Runner_CTor
func minimax_Runner_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_minimax_Runner(&minimax.Runner{}))
}

//export minimax_Runner_MinConcDepth_Get
func minimax_Runner_MinConcDepth_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_minimax_Runner(handle)
	return C.longlong(op.MinConcDepth)
}

//export minimax_Runner_MinConcDepth_Set
func minimax_Runner_MinConcDepth_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_minimax_Runner(handle)
	op.MinConcDepth = int(val)
}

//export minimax_Runner_MaxConcDepth_Get
func minimax_Runner_MaxConcDepth_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_minimax_Runner(handle)
	return C.longlong(op.MaxConcDepth)
}

//export minimax_Runner_MaxConcDepth_Set
func minimax_Runner_MaxConcDepth_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_minimax_Runner(handle)
	op.MaxConcDepth = int(val)
}

//export minimax_Runner_MiniMax
func minimax_Runner_MiniMax(_handle CGoHandle, ctx CGoHandle, state CGoHandle, depth C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*minimax.Runner")
	if __err != nil {
		return handleFromPtr_minimax_Result(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(minimax.Runner{})).(*minimax.Runner).MiniMax(ptrFromHandle_context_Context(ctx), *ptrFromHandle_match_GameState(state), int(depth))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_minimax_Result(nil)
	}
	return handleFromPtr_minimax_Result(&cret)
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export minimax_NewBot
func minimax_NewBot(runner CGoHandle, depth C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_minimax_Bot(minimax.NewBot(*ptrFromHandle_minimax_Runner(runner), int(depth)))

}

// ---- Functions ---

// ---- Package: ml ---

// ---- Types ---

// Converters for pointer handles for type: any
func ptrFromHandle_any(h CGoHandle) any {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "any")
	if p == nil {
		return nil
	}
	return p.(any)
}
func handleFromPtr_any(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("any", p))
}

// Converters for pointer handles for type: ml.Format
func ptrFromHandle_ml_Format(h CGoHandle) ml.Format {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ml.Format")
	if p == nil {
		return nil
	}
	return p.(ml.Format)
}
func handleFromPtr_ml_Format(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ml.Format", p))
}

// Converters for implicit pointer handles for type: map[string]any
func ptrFromHandle_Map_string_any(h CGoHandle) *map[string]any {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]any")
	if p == nil {
		return nil
	}
	return p.(*map[string]any)
}
func deptrFromHandle_Map_string_any(h CGoHandle) map[string]any {
	p := ptrFromHandle_Map_string_any(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_any(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]any", p))
}

// --- wrapping map: map[string]any ---
//
//export Map_string_any_CTor
func Map_string_any_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_any(&map[string]any{}))
}

//export Map_string_any_len
func Map_string_any_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_any(handle))
}

//export Map_string_any_elem
func Map_string_any_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_any(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_any(&v)
}

//export Map_string_any_contains
func Map_string_any_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_any(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_any_set
func Map_string_any_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_any(handle)
	s[C.GoString(_ky)] = ptrFromHandle_any(_vl)
}

//export Map_string_any_delete
func Map_string_any_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_any(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_any_keys
func Map_string_any_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_any(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

//export ml_Format_Row
func ml_Format_Row(_handle CGoHandle, state CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "ml.Format")
	if __err != nil {
		return handleFromPtr_Map_string_any(nil)
	}
	cret := vifc.(ml.Format).Row(*ptrFromHandle_match_GameState(state))

	return handleFromPtr_Map_string_any(&cret)
}

// ---- Structs ---

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

// ---- Functions ---

//export ml_ExportDataset
func ml_ExportDataset(out CGoHandle, data CGoHandle, format CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = ml.ExportDataset(ptrFromHandle_io_Writer(out), deptrFromHandle_Slice_minimax_Entry(data), ptrFromHandle_ml_Format(format))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// ---- Package: formats ---

// ---- Types ---

// Converters for pointer handles for type: *formats.FullStateFormat
func ptrFromHandle_Ptr_formats_FullStateFormat(h CGoHandle) *formats.FullStateFormat {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*formats.FullStateFormat")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(formats.FullStateFormat{})).(*formats.FullStateFormat)
}
func handleFromPtr_Ptr_formats_FullStateFormat(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*formats.FullStateFormat", p))
}

// Converters for pointer handles for type: *formats.PrevMovesFormat
func ptrFromHandle_Ptr_formats_PrevMovesFormat(h CGoHandle) *formats.PrevMovesFormat {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*formats.PrevMovesFormat")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(formats.PrevMovesFormat{})).(*formats.PrevMovesFormat)
}
func handleFromPtr_Ptr_formats_PrevMovesFormat(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*formats.PrevMovesFormat", p))
}

// Converters for non-pointer handles for type: formats.FullStateFormat
func ptrFromHandle_formats_FullStateFormat(h CGoHandle) *formats.FullStateFormat {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "formats.FullStateFormat")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(formats.FullStateFormat{})).(*formats.FullStateFormat)
}
func handleFromPtr_formats_FullStateFormat(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("formats.FullStateFormat", p))
}

// Converters for non-pointer handles for type: formats.PrevMovesFormat
func ptrFromHandle_formats_PrevMovesFormat(h CGoHandle) *formats.PrevMovesFormat {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "formats.PrevMovesFormat")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(formats.PrevMovesFormat{})).(*formats.PrevMovesFormat)
}
func handleFromPtr_formats_PrevMovesFormat(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("formats.PrevMovesFormat", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: formats.FullStateFormat ---
//
//export formats_FullStateFormat_CTor
func formats_FullStateFormat_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_formats_FullStateFormat(&formats.FullStateFormat{}))
}

//export formats_FullStateFormat_Row
func formats_FullStateFormat_Row(_handle CGoHandle, state CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*formats.FullStateFormat")
	if __err != nil {
		return handleFromPtr_Map_string_any(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(formats.FullStateFormat{})).(*formats.FullStateFormat).Row(*ptrFromHandle_match_GameState(state))

	return handleFromPtr_Map_string_any(&cret)
}

// --- wrapping struct: formats.PrevMovesFormat ---
//
//export formats_PrevMovesFormat_CTor
func formats_PrevMovesFormat_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_formats_PrevMovesFormat(&formats.PrevMovesFormat{}))
}

//export formats_PrevMovesFormat_Row
func formats_PrevMovesFormat_Row(_handle CGoHandle, state CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*formats.PrevMovesFormat")
	if __err != nil {
		return handleFromPtr_Map_string_any(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(formats.PrevMovesFormat{})).(*formats.PrevMovesFormat).Row(*ptrFromHandle_match_GameState(state))

	return handleFromPtr_Map_string_any(&cret)
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

// ---- Functions ---

//export formats_GetMapState
func formats_GetMapState(myin CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := formats.GetMapState(*ptrFromHandle_match_GameState(myin))

	return handleFromPtr_Map_string_any(&cret)
}

//export formats_UpdateMapChar
func formats_UpdateMapChar(c CGoHandle, opp CGoHandle, turnState CGoHandle, m CGoHandle, prefix *C.char, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	if boolPyToGo(goRun) {
		go formats.UpdateMapChar(ptrFromHandle_Ptr_game_Character(c), ptrFromHandle_Ptr_game_Character(opp), *ptrFromHandle_game_TurnState(turnState), deptrFromHandle_Map_string_any(m), C.GoString(prefix))
	} else {
		formats.UpdateMapChar(ptrFromHandle_Ptr_game_Character(c), ptrFromHandle_Ptr_game_Character(opp), *ptrFromHandle_game_TurnState(turnState), deptrFromHandle_Map_string_any(m), C.GoString(prefix))
	}
}

//export formats_UpdateMapDefence
func formats_UpdateMapDefence(mydef CGoHandle, m CGoHandle, prefix *C.char, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	if boolPyToGo(goRun) {
		go formats.UpdateMapDefence(deptrFromHandle_Map_game_Colour_int(mydef), deptrFromHandle_Map_string_any(m), C.GoString(prefix))
	} else {
		formats.UpdateMapDefence(deptrFromHandle_Map_game_Colour_int(mydef), deptrFromHandle_Map_string_any(m), C.GoString(prefix))
	}
}

//export formats_UpdateMapEffects
func formats_UpdateMapEffects(c CGoHandle, turnState CGoHandle, m CGoHandle, prefix *C.char, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	if boolPyToGo(goRun) {
		go formats.UpdateMapEffects(ptrFromHandle_Ptr_game_Character(c), *ptrFromHandle_game_TurnState(turnState), deptrFromHandle_Map_string_any(m), C.GoString(prefix))
	} else {
		formats.UpdateMapEffects(ptrFromHandle_Ptr_game_Character(c), *ptrFromHandle_game_TurnState(turnState), deptrFromHandle_Map_string_any(m), C.GoString(prefix))
	}
}

//export formats_UpdateMapSkill
func formats_UpdateMapSkill(s CGoHandle, c CGoHandle, opp CGoHandle, turnState CGoHandle, m CGoHandle, prefix *C.char, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	if boolPyToGo(goRun) {
		go formats.UpdateMapSkill(ptrFromHandle_Ptr_game_Skill(s), ptrFromHandle_Ptr_game_Character(c), ptrFromHandle_Ptr_game_Character(opp), *ptrFromHandle_game_TurnState(turnState), deptrFromHandle_Map_string_any(m), C.GoString(prefix))
	} else {
		formats.UpdateMapSkill(ptrFromHandle_Ptr_game_Skill(s), ptrFromHandle_Ptr_game_Character(c), ptrFromHandle_Ptr_game_Character(opp), *ptrFromHandle_game_TurnState(turnState), deptrFromHandle_Map_string_any(m), C.GoString(prefix))
	}
}

// ---- Package: context ---

// ---- Types ---

// Converters for pointer handles for type: context.Context
func ptrFromHandle_context_Context(h CGoHandle) context.Context {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "context.Context")
	if p == nil {
		return nil
	}
	return p.(context.Context)
}
func handleFromPtr_context_Context(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("context.Context", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

//export context_Context_Err
func context_Context_Err(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "context.Context")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(context.Context).Err()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export context_Context_Value
func context_Context_Value(_handle CGoHandle, key CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "context.Context")
	if __err != nil {
		return handleFromPtr_any(nil)
	}
	return handleFromPtr_any(vifc.(context.Context).Value(ptrFromHandle_any(key)))

}

// ---- Structs ---

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

// ---- Functions ---

//export context_WithoutCancel
func context_WithoutCancel(parent CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_context_Context(context.WithoutCancel(ptrFromHandle_context_Context(parent)))

}

//export context_Background
func context_Background() CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_context_Context(context.Background())

}

//export context_Cause
func context_Cause(c CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = context.Cause(ptrFromHandle_context_Context(c))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export context_TODO
func context_TODO() CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_context_Context(context.TODO())

}

//export context_WithValue
func context_WithValue(parent CGoHandle, key CGoHandle, val CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_context_Context(context.WithValue(ptrFromHandle_context_Context(parent), ptrFromHandle_any(key), ptrFromHandle_any(val)))

}

// ---- Package: json ---

// ---- Types ---

// Converters for pointer handles for type: *json.Decoder
func ptrFromHandle_Ptr_json_Decoder(h CGoHandle) *json.Decoder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*json.Decoder")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(json.Decoder{})).(*json.Decoder)
}
func handleFromPtr_Ptr_json_Decoder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*json.Decoder", p))
}

// Converters for pointer handles for type: *json.Encoder
func ptrFromHandle_Ptr_json_Encoder(h CGoHandle) *json.Encoder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*json.Encoder")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(json.Encoder{})).(*json.Encoder)
}
func handleFromPtr_Ptr_json_Encoder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*json.Encoder", p))
}

// Converters for pointer handles for type: *json.InvalidUTF8Error
func ptrFromHandle_Ptr_json_InvalidUTF8Error(h CGoHandle) *json.InvalidUTF8Error {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*json.InvalidUTF8Error")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(json.InvalidUTF8Error{})).(*json.InvalidUTF8Error)
}
func handleFromPtr_Ptr_json_InvalidUTF8Error(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*json.InvalidUTF8Error", p))
}

// Converters for pointer handles for type: *json.InvalidUnmarshalError
func ptrFromHandle_Ptr_json_InvalidUnmarshalError(h CGoHandle) *json.InvalidUnmarshalError {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*json.InvalidUnmarshalError")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(json.InvalidUnmarshalError{})).(*json.InvalidUnmarshalError)
}
func handleFromPtr_Ptr_json_InvalidUnmarshalError(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*json.InvalidUnmarshalError", p))
}

// Converters for pointer handles for type: *json.MarshalerError
func ptrFromHandle_Ptr_json_MarshalerError(h CGoHandle) *json.MarshalerError {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*json.MarshalerError")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(json.MarshalerError{})).(*json.MarshalerError)
}
func handleFromPtr_Ptr_json_MarshalerError(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*json.MarshalerError", p))
}

// Converters for pointer handles for type: *json.RawMessage
func ptrFromHandle_Ptr_json_RawMessage(h CGoHandle) *json.RawMessage {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*json.RawMessage")
	if p == nil {
		return nil
	}
	return p.(*json.RawMessage)
}
func handleFromPtr_Ptr_json_RawMessage(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*json.RawMessage", p))
}

// Converters for pointer handles for type: *json.SyntaxError
func ptrFromHandle_Ptr_json_SyntaxError(h CGoHandle) *json.SyntaxError {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*json.SyntaxError")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(json.SyntaxError{})).(*json.SyntaxError)
}
func handleFromPtr_Ptr_json_SyntaxError(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*json.SyntaxError", p))
}

// Converters for pointer handles for type: *json.UnmarshalFieldError
func ptrFromHandle_Ptr_json_UnmarshalFieldError(h CGoHandle) *json.UnmarshalFieldError {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*json.UnmarshalFieldError")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(json.UnmarshalFieldError{})).(*json.UnmarshalFieldError)
}
func handleFromPtr_Ptr_json_UnmarshalFieldError(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*json.UnmarshalFieldError", p))
}

// Converters for pointer handles for type: *json.UnmarshalTypeError
func ptrFromHandle_Ptr_json_UnmarshalTypeError(h CGoHandle) *json.UnmarshalTypeError {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*json.UnmarshalTypeError")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(json.UnmarshalTypeError{})).(*json.UnmarshalTypeError)
}
func handleFromPtr_Ptr_json_UnmarshalTypeError(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*json.UnmarshalTypeError", p))
}

// Converters for pointer handles for type: *json.UnsupportedTypeError
func ptrFromHandle_Ptr_json_UnsupportedTypeError(h CGoHandle) *json.UnsupportedTypeError {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*json.UnsupportedTypeError")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(json.UnsupportedTypeError{})).(*json.UnsupportedTypeError)
}
func handleFromPtr_Ptr_json_UnsupportedTypeError(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*json.UnsupportedTypeError", p))
}

// Converters for pointer handles for type: *json.UnsupportedValueError
func ptrFromHandle_Ptr_json_UnsupportedValueError(h CGoHandle) *json.UnsupportedValueError {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*json.UnsupportedValueError")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(json.UnsupportedValueError{})).(*json.UnsupportedValueError)
}
func handleFromPtr_Ptr_json_UnsupportedValueError(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*json.UnsupportedValueError", p))
}

// Converters for implicit pointer handles for type: [2]uintptr
func ptrFromHandle_Array_2_uintptr(h CGoHandle) *[2]uintptr {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[2]uintptr")
	if p == nil {
		return nil
	}
	return p.(*[2]uintptr)
}
func deptrFromHandle_Array_2_uintptr(h CGoHandle) [2]uintptr {
	p := ptrFromHandle_Array_2_uintptr(h)
	return *p
}
func handleFromPtr_Array_2_uintptr(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[2]uintptr", p))
}

// --- wrapping slice: [2]uintptr ---
//
//export Array_2_uintptr_CTor
func Array_2_uintptr_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Array_2_uintptr(&[2]uintptr{}))
}

//export Array_2_uintptr_len
func Array_2_uintptr_len(handle CGoHandle) int {
	return len(deptrFromHandle_Array_2_uintptr(handle))
}

//export Array_2_uintptr_elem
func Array_2_uintptr_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Array_2_uintptr(handle)
	return C.ulonglong(s[_idx])
}

//export Array_2_uintptr_set
func Array_2_uintptr_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Array_2_uintptr(handle)
	s[_idx] = uintptr(_vl)
}

// Converters for implicit pointer handles for type: []reflect.Value
func ptrFromHandle_Slice_reflect_Value(h CGoHandle) *[]reflect.Value {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]reflect.Value")
	if p == nil {
		return nil
	}
	return p.(*[]reflect.Value)
}
func deptrFromHandle_Slice_reflect_Value(h CGoHandle) []reflect.Value {
	p := ptrFromHandle_Slice_reflect_Value(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_reflect_Value(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]reflect.Value", p))
}

// --- wrapping slice: []reflect.Value ---
//
//export Slice_reflect_Value_CTor
func Slice_reflect_Value_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_reflect_Value(&[]reflect.Value{}))
}

//export Slice_reflect_Value_len
func Slice_reflect_Value_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_reflect_Value(handle))
}

//export Slice_reflect_Value_elem
func Slice_reflect_Value_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_reflect_Value(handle)
	return handleFromPtr_reflect_Value(&(s[_idx]))
}

//export Slice_reflect_Value_subslice
func Slice_reflect_Value_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_reflect_Value(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_reflect_Value(&ss))
}

//export Slice_reflect_Value_set
func Slice_reflect_Value_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_reflect_Value(handle)
	s[_idx] = *ptrFromHandle_reflect_Value(_vl)
}

//export Slice_reflect_Value_append
func Slice_reflect_Value_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_reflect_Value(handle)
	*s = append(*s, *ptrFromHandle_reflect_Value(_vl))
}

// Converters for non-pointer handles for type: json.Decoder
func ptrFromHandle_json_Decoder(h CGoHandle) *json.Decoder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "json.Decoder")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(json.Decoder{})).(*json.Decoder)
}
func handleFromPtr_json_Decoder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("json.Decoder", p))
}

// Converters for non-pointer handles for type: json.Encoder
func ptrFromHandle_json_Encoder(h CGoHandle) *json.Encoder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "json.Encoder")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(json.Encoder{})).(*json.Encoder)
}
func handleFromPtr_json_Encoder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("json.Encoder", p))
}

// Converters for non-pointer handles for type: json.InvalidUTF8Error
func ptrFromHandle_json_InvalidUTF8Error(h CGoHandle) *json.InvalidUTF8Error {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "json.InvalidUTF8Error")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(json.InvalidUTF8Error{})).(*json.InvalidUTF8Error)
}
func handleFromPtr_json_InvalidUTF8Error(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("json.InvalidUTF8Error", p))
}

// Converters for non-pointer handles for type: json.InvalidUnmarshalError
func ptrFromHandle_json_InvalidUnmarshalError(h CGoHandle) *json.InvalidUnmarshalError {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "json.InvalidUnmarshalError")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(json.InvalidUnmarshalError{})).(*json.InvalidUnmarshalError)
}
func handleFromPtr_json_InvalidUnmarshalError(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("json.InvalidUnmarshalError", p))
}

// Converters for pointer handles for type: json.Marshaler
func ptrFromHandle_json_Marshaler(h CGoHandle) json.Marshaler {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "json.Marshaler")
	if p == nil {
		return nil
	}
	return p.(json.Marshaler)
}
func handleFromPtr_json_Marshaler(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("json.Marshaler", p))
}

// Converters for non-pointer handles for type: json.MarshalerError
func ptrFromHandle_json_MarshalerError(h CGoHandle) *json.MarshalerError {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "json.MarshalerError")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(json.MarshalerError{})).(*json.MarshalerError)
}
func handleFromPtr_json_MarshalerError(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("json.MarshalerError", p))
}

// Converters for implicit pointer handles for type: json.RawMessage
func ptrFromHandle_json_RawMessage(h CGoHandle) *json.RawMessage {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "json.RawMessage")
	if p == nil {
		return nil
	}
	return p.(*json.RawMessage)
}
func deptrFromHandle_json_RawMessage(h CGoHandle) json.RawMessage {
	p := ptrFromHandle_json_RawMessage(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_json_RawMessage(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("json.RawMessage", p))
}

// Converters for non-pointer handles for type: json.SyntaxError
func ptrFromHandle_json_SyntaxError(h CGoHandle) *json.SyntaxError {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "json.SyntaxError")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(json.SyntaxError{})).(*json.SyntaxError)
}
func handleFromPtr_json_SyntaxError(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("json.SyntaxError", p))
}

// Converters for pointer handles for type: json.Token
func ptrFromHandle_json_Token(h CGoHandle) json.Token {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "json.Token")
	if p == nil {
		return nil
	}
	return p.(json.Token)
}
func handleFromPtr_json_Token(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("json.Token", p))
}

// Converters for non-pointer handles for type: json.UnmarshalFieldError
func ptrFromHandle_json_UnmarshalFieldError(h CGoHandle) *json.UnmarshalFieldError {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "json.UnmarshalFieldError")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(json.UnmarshalFieldError{})).(*json.UnmarshalFieldError)
}
func handleFromPtr_json_UnmarshalFieldError(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("json.UnmarshalFieldError", p))
}

// Converters for non-pointer handles for type: json.UnmarshalTypeError
func ptrFromHandle_json_UnmarshalTypeError(h CGoHandle) *json.UnmarshalTypeError {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "json.UnmarshalTypeError")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(json.UnmarshalTypeError{})).(*json.UnmarshalTypeError)
}
func handleFromPtr_json_UnmarshalTypeError(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("json.UnmarshalTypeError", p))
}

// Converters for pointer handles for type: json.Unmarshaler
func ptrFromHandle_json_Unmarshaler(h CGoHandle) json.Unmarshaler {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "json.Unmarshaler")
	if p == nil {
		return nil
	}
	return p.(json.Unmarshaler)
}
func handleFromPtr_json_Unmarshaler(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("json.Unmarshaler", p))
}

// Converters for non-pointer handles for type: json.UnsupportedTypeError
func ptrFromHandle_json_UnsupportedTypeError(h CGoHandle) *json.UnsupportedTypeError {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "json.UnsupportedTypeError")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(json.UnsupportedTypeError{})).(*json.UnsupportedTypeError)
}
func handleFromPtr_json_UnsupportedTypeError(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("json.UnsupportedTypeError", p))
}

// Converters for non-pointer handles for type: json.UnsupportedValueError
func ptrFromHandle_json_UnsupportedValueError(h CGoHandle) *json.UnsupportedValueError {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "json.UnsupportedValueError")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(json.UnsupportedValueError{})).(*json.UnsupportedValueError)
}
func handleFromPtr_json_UnsupportedValueError(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("json.UnsupportedValueError", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

//export json_Marshaler_MarshalJSON
func json_Marshaler_MarshalJSON(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "json.Marshaler")
	if __err != nil {
		return handleFromPtr_Slice_byte(nil)
	}
	cret, __err := vifc.(json.Marshaler).MarshalJSON()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_byte(nil)
	}
	return handleFromPtr_Slice_byte(&cret)
}

//export json_Unmarshaler_UnmarshalJSON
func json_Unmarshaler_UnmarshalJSON(_handle CGoHandle, arg_0 CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "json.Unmarshaler")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(json.Unmarshaler).UnmarshalJSON(deptrFromHandle_Slice_byte(arg_0))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// ---- Structs ---

// --- wrapping struct: json.InvalidUTF8Error ---
//
//export json_InvalidUTF8Error_CTor
func json_InvalidUTF8Error_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_json_InvalidUTF8Error(&json.InvalidUTF8Error{}))
}

//export json_InvalidUTF8Error_S_Get
func json_InvalidUTF8Error_S_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_json_InvalidUTF8Error(handle)
	return C.CString(op.S)
}

//export json_InvalidUTF8Error_S_Set
func json_InvalidUTF8Error_S_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_json_InvalidUTF8Error(handle)
	op.S = C.GoString(val)
}

//export json_InvalidUTF8Error_Error
func json_InvalidUTF8Error_Error(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*json.InvalidUTF8Error")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(gopyh.Embed(vifc, reflect.TypeOf(json.InvalidUTF8Error{})).(*json.InvalidUTF8Error).Error())

}

// --- wrapping struct: json.MarshalerError ---
//
//export json_MarshalerError_CTor
func json_MarshalerError_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_json_MarshalerError(&json.MarshalerError{}))
}

//export json_MarshalerError_Type_Get
func json_MarshalerError_Type_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_json_MarshalerError(handle)
	return handleFromPtr_reflect_Type(op.Type)
}

//export json_MarshalerError_Type_Set
func json_MarshalerError_Type_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_json_MarshalerError(handle)
	op.Type = ptrFromHandle_reflect_Type(val)
}

//export json_MarshalerError_Error
func json_MarshalerError_Error(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*json.MarshalerError")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(gopyh.Embed(vifc, reflect.TypeOf(json.MarshalerError{})).(*json.MarshalerError).Error())

}

//export json_MarshalerError_Unwrap
func json_MarshalerError_Unwrap(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*json.MarshalerError")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(json.MarshalerError{})).(*json.MarshalerError).Unwrap()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: json.SyntaxError ---
//
//export json_SyntaxError_CTor
func json_SyntaxError_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_json_SyntaxError(&json.SyntaxError{}))
}

//export json_SyntaxError_Offset_Get
func json_SyntaxError_Offset_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_json_SyntaxError(handle)
	return C.longlong(op.Offset)
}

//export json_SyntaxError_Offset_Set
func json_SyntaxError_Offset_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_json_SyntaxError(handle)
	op.Offset = int64(val)
}

//export json_SyntaxError_Error
func json_SyntaxError_Error(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*json.SyntaxError")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(gopyh.Embed(vifc, reflect.TypeOf(json.SyntaxError{})).(*json.SyntaxError).Error())

}

// --- wrapping struct: json.UnsupportedTypeError ---
//
//export json_UnsupportedTypeError_CTor
func json_UnsupportedTypeError_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_json_UnsupportedTypeError(&json.UnsupportedTypeError{}))
}

//export json_UnsupportedTypeError_Type_Get
func json_UnsupportedTypeError_Type_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_json_UnsupportedTypeError(handle)
	return handleFromPtr_reflect_Type(op.Type)
}

//export json_UnsupportedTypeError_Type_Set
func json_UnsupportedTypeError_Type_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_json_UnsupportedTypeError(handle)
	op.Type = ptrFromHandle_reflect_Type(val)
}

//export json_UnsupportedTypeError_Error
func json_UnsupportedTypeError_Error(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*json.UnsupportedTypeError")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(gopyh.Embed(vifc, reflect.TypeOf(json.UnsupportedTypeError{})).(*json.UnsupportedTypeError).Error())

}

// --- wrapping struct: json.UnsupportedValueError ---
//
//export json_UnsupportedValueError_CTor
func json_UnsupportedValueError_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_json_UnsupportedValueError(&json.UnsupportedValueError{}))
}

//export json_UnsupportedValueError_Value_Get
func json_UnsupportedValueError_Value_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_json_UnsupportedValueError(handle)
	return handleFromPtr_reflect_Value(&op.Value)
}

//export json_UnsupportedValueError_Value_Set
func json_UnsupportedValueError_Value_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_json_UnsupportedValueError(handle)
	op.Value = *ptrFromHandle_reflect_Value(val)
}

//export json_UnsupportedValueError_Str_Get
func json_UnsupportedValueError_Str_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_json_UnsupportedValueError(handle)
	return C.CString(op.Str)
}

//export json_UnsupportedValueError_Str_Set
func json_UnsupportedValueError_Str_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_json_UnsupportedValueError(handle)
	op.Str = C.GoString(val)
}

//export json_UnsupportedValueError_Error
func json_UnsupportedValueError_Error(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*json.UnsupportedValueError")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(gopyh.Embed(vifc, reflect.TypeOf(json.UnsupportedValueError{})).(*json.UnsupportedValueError).Error())

}

// --- wrapping struct: json.Decoder ---
//
//export json_Decoder_CTor
func json_Decoder_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_json_Decoder(&json.Decoder{}))
}

//export json_Decoder_UseNumber
func json_Decoder_UseNumber(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*json.Decoder")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(json.Decoder{})).(*json.Decoder).UseNumber()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(json.Decoder{})).(*json.Decoder).UseNumber()
	}
}

//export json_Decoder_DisallowUnknownFields
func json_Decoder_DisallowUnknownFields(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*json.Decoder")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(json.Decoder{})).(*json.Decoder).DisallowUnknownFields()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(json.Decoder{})).(*json.Decoder).DisallowUnknownFields()
	}
}

//export json_Decoder_Decode
func json_Decoder_Decode(_handle CGoHandle, v CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*json.Decoder")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(json.Decoder{})).(*json.Decoder).Decode(ptrFromHandle_any(v))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export json_Decoder_Buffered
func json_Decoder_Buffered(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*json.Decoder")
	if __err != nil {
		return handleFromPtr_io_Reader(nil)
	}
	return handleFromPtr_io_Reader(gopyh.Embed(vifc, reflect.TypeOf(json.Decoder{})).(*json.Decoder).Buffered())

}

//export json_Decoder_Token
func json_Decoder_Token(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*json.Decoder")
	if __err != nil {
		return handleFromPtr_json_Token(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(json.Decoder{})).(*json.Decoder).Token()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_json_Token(nil)
	}
	return handleFromPtr_json_Token(cret)
}

//export json_Decoder_More
func json_Decoder_More(_handle CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*json.Decoder")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(gopyh.Embed(vifc, reflect.TypeOf(json.Decoder{})).(*json.Decoder).More())

}

//export json_Decoder_InputOffset
func json_Decoder_InputOffset(_handle CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*json.Decoder")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(gopyh.Embed(vifc, reflect.TypeOf(json.Decoder{})).(*json.Decoder).InputOffset())

}

// --- wrapping struct: json.Encoder ---
//
//export json_Encoder_CTor
func json_Encoder_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_json_Encoder(&json.Encoder{}))
}

//export json_Encoder_Encode
func json_Encoder_Encode(_handle CGoHandle, v CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*json.Encoder")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(json.Encoder{})).(*json.Encoder).Encode(ptrFromHandle_any(v))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export json_Encoder_SetIndent
func json_Encoder_SetIndent(_handle CGoHandle, prefix *C.char, indent *C.char, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*json.Encoder")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(json.Encoder{})).(*json.Encoder).SetIndent(C.GoString(prefix), C.GoString(indent))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(json.Encoder{})).(*json.Encoder).SetIndent(C.GoString(prefix), C.GoString(indent))
	}
}

//export json_Encoder_SetEscapeHTML
func json_Encoder_SetEscapeHTML(_handle CGoHandle, on C.char, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*json.Encoder")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(json.Encoder{})).(*json.Encoder).SetEscapeHTML(boolPyToGo(on))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(json.Encoder{})).(*json.Encoder).SetEscapeHTML(boolPyToGo(on))
	}
}

// --- wrapping struct: json.UnmarshalTypeError ---
//
//export json_UnmarshalTypeError_CTor
func json_UnmarshalTypeError_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_json_UnmarshalTypeError(&json.UnmarshalTypeError{}))
}

//export json_UnmarshalTypeError_Value_Get
func json_UnmarshalTypeError_Value_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_json_UnmarshalTypeError(handle)
	return C.CString(op.Value)
}

//export json_UnmarshalTypeError_Value_Set
func json_UnmarshalTypeError_Value_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_json_UnmarshalTypeError(handle)
	op.Value = C.GoString(val)
}

//export json_UnmarshalTypeError_Type_Get
func json_UnmarshalTypeError_Type_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_json_UnmarshalTypeError(handle)
	return handleFromPtr_reflect_Type(op.Type)
}

//export json_UnmarshalTypeError_Type_Set
func json_UnmarshalTypeError_Type_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_json_UnmarshalTypeError(handle)
	op.Type = ptrFromHandle_reflect_Type(val)
}

//export json_UnmarshalTypeError_Offset_Get
func json_UnmarshalTypeError_Offset_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_json_UnmarshalTypeError(handle)
	return C.longlong(op.Offset)
}

//export json_UnmarshalTypeError_Offset_Set
func json_UnmarshalTypeError_Offset_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_json_UnmarshalTypeError(handle)
	op.Offset = int64(val)
}

//export json_UnmarshalTypeError_Struct_Get
func json_UnmarshalTypeError_Struct_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_json_UnmarshalTypeError(handle)
	return C.CString(op.Struct)
}

//export json_UnmarshalTypeError_Struct_Set
func json_UnmarshalTypeError_Struct_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_json_UnmarshalTypeError(handle)
	op.Struct = C.GoString(val)
}

//export json_UnmarshalTypeError_Field_Get
func json_UnmarshalTypeError_Field_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_json_UnmarshalTypeError(handle)
	return C.CString(op.Field)
}

//export json_UnmarshalTypeError_Field_Set
func json_UnmarshalTypeError_Field_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_json_UnmarshalTypeError(handle)
	op.Field = C.GoString(val)
}

//export json_UnmarshalTypeError_Error
func json_UnmarshalTypeError_Error(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*json.UnmarshalTypeError")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(gopyh.Embed(vifc, reflect.TypeOf(json.UnmarshalTypeError{})).(*json.UnmarshalTypeError).Error())

}

// --- wrapping struct: json.InvalidUnmarshalError ---
//
//export json_InvalidUnmarshalError_CTor
func json_InvalidUnmarshalError_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_json_InvalidUnmarshalError(&json.InvalidUnmarshalError{}))
}

//export json_InvalidUnmarshalError_Type_Get
func json_InvalidUnmarshalError_Type_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_json_InvalidUnmarshalError(handle)
	return handleFromPtr_reflect_Type(op.Type)
}

//export json_InvalidUnmarshalError_Type_Set
func json_InvalidUnmarshalError_Type_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_json_InvalidUnmarshalError(handle)
	op.Type = ptrFromHandle_reflect_Type(val)
}

//export json_InvalidUnmarshalError_Error
func json_InvalidUnmarshalError_Error(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*json.InvalidUnmarshalError")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(gopyh.Embed(vifc, reflect.TypeOf(json.InvalidUnmarshalError{})).(*json.InvalidUnmarshalError).Error())

}

// --- wrapping struct: json.UnmarshalFieldError ---
//
//export json_UnmarshalFieldError_CTor
func json_UnmarshalFieldError_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_json_UnmarshalFieldError(&json.UnmarshalFieldError{}))
}

//export json_UnmarshalFieldError_Key_Get
func json_UnmarshalFieldError_Key_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_json_UnmarshalFieldError(handle)
	return C.CString(op.Key)
}

//export json_UnmarshalFieldError_Key_Set
func json_UnmarshalFieldError_Key_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_json_UnmarshalFieldError(handle)
	op.Key = C.GoString(val)
}

//export json_UnmarshalFieldError_Type_Get
func json_UnmarshalFieldError_Type_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_json_UnmarshalFieldError(handle)
	return handleFromPtr_reflect_Type(op.Type)
}

//export json_UnmarshalFieldError_Type_Set
func json_UnmarshalFieldError_Type_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_json_UnmarshalFieldError(handle)
	op.Type = ptrFromHandle_reflect_Type(val)
}

//export json_UnmarshalFieldError_Field_Get
func json_UnmarshalFieldError_Field_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_json_UnmarshalFieldError(handle)
	return handleFromPtr_reflect_StructField(&op.Field)
}

//export json_UnmarshalFieldError_Field_Set
func json_UnmarshalFieldError_Field_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_json_UnmarshalFieldError(handle)
	op.Field = *ptrFromHandle_reflect_StructField(val)
}

//export json_UnmarshalFieldError_Error
func json_UnmarshalFieldError_Error(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*json.UnmarshalFieldError")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(gopyh.Embed(vifc, reflect.TypeOf(json.UnmarshalFieldError{})).(*json.UnmarshalFieldError).Error())

}

// ---- Slices ---

// --- wrapping slice: json.RawMessage ---
//
//export json_RawMessage_CTor
func json_RawMessage_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_json_RawMessage(&json.RawMessage{}))
}

//export json_RawMessage_len
func json_RawMessage_len(handle CGoHandle) int {
	return len(deptrFromHandle_json_RawMessage(handle))
}

//export json_RawMessage_elem
func json_RawMessage_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_json_RawMessage(handle)
	return C.char(s[_idx])
}

//export json_RawMessage_subslice
func json_RawMessage_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_json_RawMessage(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_json_RawMessage(&ss))
}

//export json_RawMessage_set
func json_RawMessage_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_json_RawMessage(handle)
	s[_idx] = byte(_vl)
}

//export json_RawMessage_append
func json_RawMessage_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_json_RawMessage(handle)
	*s = append(*s, byte(_vl))
}

//export json_RawMessage_MarshalJSON
func json_RawMessage_MarshalJSON(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*json.RawMessage")
	if __err != nil {
		return handleFromPtr_Slice_byte(nil)
	}
	cret, __err := vifc.(*json.RawMessage).MarshalJSON()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_byte(nil)
	}
	return handleFromPtr_Slice_byte(&cret)
}

//export json_RawMessage_UnmarshalJSON
func json_RawMessage_UnmarshalJSON(_handle CGoHandle, data CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*json.RawMessage")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(*json.RawMessage).UnmarshalJSON(deptrFromHandle_Slice_byte(data))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// ---- Maps ---

// ---- Constructors ---

//export json_NewDecoder
func json_NewDecoder(r CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_json_Decoder(json.NewDecoder(ptrFromHandle_io_Reader(r)))

}

//export json_NewEncoder
func json_NewEncoder(w CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_json_Encoder(json.NewEncoder(ptrFromHandle_io_Writer(w)))

}

// ---- Functions ---

//export json_Valid
func json_Valid(data CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return boolGoToPy(json.Valid(deptrFromHandle_Slice_byte(data)))

}

//export json_Compact
func json_Compact(dst CGoHandle, src CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = json.Compact(ptrFromHandle_Ptr_bytes_Buffer(dst), deptrFromHandle_Slice_byte(src))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export json_MarshalIndent
func json_MarshalIndent(v CGoHandle, prefix *C.char, indent *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := json.MarshalIndent(ptrFromHandle_any(v), C.GoString(prefix), C.GoString(indent))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_byte(nil)
	}
	return handleFromPtr_Slice_byte(&cret)
}

//export json_Marshal
func json_Marshal(v CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := json.Marshal(ptrFromHandle_any(v))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_byte(nil)
	}
	return handleFromPtr_Slice_byte(&cret)
}

//export json_Unmarshal
func json_Unmarshal(data CGoHandle, v CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = json.Unmarshal(deptrFromHandle_Slice_byte(data), ptrFromHandle_any(v))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export json_HTMLEscape
func json_HTMLEscape(dst CGoHandle, src CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	if boolPyToGo(goRun) {
		go json.HTMLEscape(ptrFromHandle_Ptr_bytes_Buffer(dst), deptrFromHandle_Slice_byte(src))
	} else {
		json.HTMLEscape(ptrFromHandle_Ptr_bytes_Buffer(dst), deptrFromHandle_Slice_byte(src))
	}
}

//export json_Indent
func json_Indent(dst CGoHandle, src CGoHandle, prefix *C.char, indent *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = json.Indent(ptrFromHandle_Ptr_bytes_Buffer(dst), deptrFromHandle_Slice_byte(src), C.GoString(prefix), C.GoString(indent))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}
