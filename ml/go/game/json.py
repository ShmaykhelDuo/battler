"""
Package json implements encoding and decoding of JSON as defined in
RFC 7159. The mapping between JSON and Go values is described
in the documentation for the Marshal and Unmarshal functions.

See "JSON and Go" for an introduction to this package:
https://golang.org/doc/articles/json_and_go.html

"""
# python wrapper for package encoding/json within overall package game
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy pkg -exclude=model,ml1,ml2,moveml ../../internal/game ../../internal/bot context encoding/json

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _game
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from game import json
# and then refer to everything using json. prefix
# packages imported by this package listed below:




# ---- Types ---

# Python type for slice [2]uintptr
class Array_2_uintptr(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
	def __del__(self):
		_game.DecRef(self.handle)
	def __str__(self):
		s = 'json.Array_2_uintptr len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'json.Array_2_uintptr([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _game.Array_2_uintptr_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _game.Array_2_uintptr_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_game.Array_2_uintptr_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _game.Array_2_uintptr_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration

# Python type for slice []reflect.Value
class Slice_reflect_Value(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = _game.Slice_reflect_Value_CTor()
			_game.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_reflect_Value.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_game.DecRef(self.handle)
	def __str__(self):
		s = 'json.Slice_reflect_Value len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'json.Slice_reflect_Value([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _game.Slice_reflect_Value_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _game.Slice_reflect_Value_len(self.handle)
				return Slice_reflect_Value(handle=_game.Slice_reflect_Value_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.reflect_Value(handle=_game.Slice_reflect_Value_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_game.Slice_reflect_Value_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_reflect_Value.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.reflect_Value(handle=_game.Slice_reflect_Value_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_game.Slice_reflect_Value_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---

# Python type for interface json.Marshaler
class Marshaler(go.GoClass):
	"""Marshaler is the interface implemented by types that\ncan marshal themselves into valid JSON.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = 0
	def MarshalJSON(self):
		"""MarshalJSON() []int, str"""
		return go.Slice_byte(handle=_game.json_Marshaler_MarshalJSON(self.handle))

# Python type for interface json.Token
class Token(go.GoClass):
	"""A Token holds a value of one of these types:\n\n  - [Delim], for the four JSON delimiters [ ] { }\n  - bool, for JSON booleans\n  - float64, for JSON numbers\n  - [Number], for JSON numbers\n  - string, for JSON string literals\n  - nil, for JSON null\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = 0

# Python type for interface json.Unmarshaler
class Unmarshaler(go.GoClass):
	"""Unmarshaler is the interface implemented by types\nthat can unmarshal a JSON description of themselves.\nThe input can be assumed to be a valid encoding of\na JSON value. UnmarshalJSON must copy the JSON data\nif it wishes to retain the data after returning.\n\nBy convention, to approximate the behavior of [Unmarshal] itself,\nUnmarshalers implement UnmarshalJSON([]byte(\"null\")) as a no-op.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = 0
	def UnmarshalJSON(self, arg_0):
		"""UnmarshalJSON([]int) str"""
		return _game.json_Unmarshaler_UnmarshalJSON(self.handle, arg_0.handle)


# ---- Structs ---

# Python type for struct json.InvalidUTF8Error
class InvalidUTF8Error(go.GoClass):
	"""Before Go 1.2, an InvalidUTF8Error was returned by [Marshal] when\nattempting to encode a string value with invalid UTF-8 sequences.\nAs of Go 1.2, [Marshal] instead coerces the string to valid UTF-8 by\nreplacing invalid bytes with the Unicode replacement rune U+FFFD.\n\nDeprecated: No longer used; kept for compatibility.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = _game.json_InvalidUTF8Error_CTor()
			_game.IncRef(self.handle)
			if  0 < len(args):
				self.S = args[0]
			if "S" in kwargs:
				self.S = kwargs["S"]
	def __del__(self):
		_game.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'json.InvalidUTF8Error{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'json.InvalidUTF8Error ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def S(self):
		return _game.json_InvalidUTF8Error_S_Get(self.handle)
	@S.setter
	def S(self, value):
		if isinstance(value, go.GoClass):
			_game.json_InvalidUTF8Error_S_Set(self.handle, value.handle)
		else:
			_game.json_InvalidUTF8Error_S_Set(self.handle, value)
	def Error(self):
		"""Error() str"""
		return _game.json_InvalidUTF8Error_Error(self.handle)

# Python type for struct json.MarshalerError
class MarshalerError(go.GoClass):
	"""A MarshalerError represents an error from calling a\n[Marshaler.MarshalJSON] or [encoding.TextMarshaler.MarshalText] method.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = _game.json_MarshalerError_CTor()
			_game.IncRef(self.handle)
			if  0 < len(args):
				self.Type = args[0]
			if "Type" in kwargs:
				self.Type = kwargs["Type"]
	def __del__(self):
		_game.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'json.MarshalerError{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'json.MarshalerError ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Type(self):
		return go.reflect_Type(handle=_game.json_MarshalerError_Type_Get(self.handle))
	@Type.setter
	def Type(self, value):
		if isinstance(value, go.GoClass):
			_game.json_MarshalerError_Type_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def Error(self):
		"""Error() str"""
		return _game.json_MarshalerError_Error(self.handle)
	def Unwrap(self):
		"""Unwrap() str
		
		Unwrap returns the underlying error.
		"""
		return _game.json_MarshalerError_Unwrap(self.handle)

# Python type for struct json.SyntaxError
class SyntaxError(go.GoClass):
	"""A SyntaxError is a description of a JSON syntax error.\n[Unmarshal] will return a SyntaxError if the JSON can't be parsed.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = _game.json_SyntaxError_CTor()
			_game.IncRef(self.handle)
			if  1 < len(args):
				self.Offset = args[1]
			if "Offset" in kwargs:
				self.Offset = kwargs["Offset"]
	def __del__(self):
		_game.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'json.SyntaxError{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'json.SyntaxError ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Offset(self):
		return _game.json_SyntaxError_Offset_Get(self.handle)
	@Offset.setter
	def Offset(self, value):
		if isinstance(value, go.GoClass):
			_game.json_SyntaxError_Offset_Set(self.handle, value.handle)
		else:
			_game.json_SyntaxError_Offset_Set(self.handle, value)
	def Error(self):
		"""Error() str"""
		return _game.json_SyntaxError_Error(self.handle)

# Python type for struct json.UnsupportedTypeError
class UnsupportedTypeError(go.GoClass):
	"""An UnsupportedTypeError is returned by [Marshal] when attempting\nto encode an unsupported value type.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = _game.json_UnsupportedTypeError_CTor()
			_game.IncRef(self.handle)
			if  0 < len(args):
				self.Type = args[0]
			if "Type" in kwargs:
				self.Type = kwargs["Type"]
	def __del__(self):
		_game.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'json.UnsupportedTypeError{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'json.UnsupportedTypeError ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Type(self):
		return go.reflect_Type(handle=_game.json_UnsupportedTypeError_Type_Get(self.handle))
	@Type.setter
	def Type(self, value):
		if isinstance(value, go.GoClass):
			_game.json_UnsupportedTypeError_Type_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def Error(self):
		"""Error() str"""
		return _game.json_UnsupportedTypeError_Error(self.handle)

# Python type for struct json.UnsupportedValueError
class UnsupportedValueError(go.GoClass):
	"""An UnsupportedValueError is returned by [Marshal] when attempting\nto encode an unsupported value.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = _game.json_UnsupportedValueError_CTor()
			_game.IncRef(self.handle)
			if  0 < len(args):
				self.Value = args[0]
			if "Value" in kwargs:
				self.Value = kwargs["Value"]
			if  1 < len(args):
				self.Str = args[1]
			if "Str" in kwargs:
				self.Str = kwargs["Str"]
	def __del__(self):
		_game.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'json.UnsupportedValueError{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'json.UnsupportedValueError ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Value(self):
		return go.reflect_Value(handle=_game.json_UnsupportedValueError_Value_Get(self.handle))
	@Value.setter
	def Value(self, value):
		if isinstance(value, go.GoClass):
			_game.json_UnsupportedValueError_Value_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Str(self):
		return _game.json_UnsupportedValueError_Str_Get(self.handle)
	@Str.setter
	def Str(self, value):
		if isinstance(value, go.GoClass):
			_game.json_UnsupportedValueError_Str_Set(self.handle, value.handle)
		else:
			_game.json_UnsupportedValueError_Str_Set(self.handle, value)
	def Error(self):
		"""Error() str"""
		return _game.json_UnsupportedValueError_Error(self.handle)

# Python type for struct json.Decoder
class Decoder(go.GoClass):
	"""A Decoder reads and decodes JSON values from an input stream.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = _game.json_Decoder_CTor()
			_game.IncRef(self.handle)
	def __del__(self):
		_game.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'json.Decoder{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'json.Decoder ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def UseNumber(self, goRun=False):
		"""UseNumber() 
		
		UseNumber causes the Decoder to unmarshal a number into an interface{} as a
		[Number] instead of as a float64.
		"""
		_game.json_Decoder_UseNumber(self.handle, goRun)
	def DisallowUnknownFields(self, goRun=False):
		"""DisallowUnknownFields() 
		
		DisallowUnknownFields causes the Decoder to return an error when the destination
		is a struct and the input contains object keys which do not match any
		non-ignored, exported fields in the destination.
		"""
		_game.json_Decoder_DisallowUnknownFields(self.handle, goRun)
	def Decode(self, v):
		"""Decode(object v) str
		
		Decode reads the next JSON-encoded value from its
		input and stores it in the value pointed to by v.
		
		See the documentation for [Unmarshal] for details about
		the conversion of JSON into a Go value.
		"""
		return _game.json_Decoder_Decode(self.handle, v.handle)
	def Buffered(self):
		"""Buffered() object
		
		Buffered returns a reader of the data remaining in the Decoder's
		buffer. The reader is valid until the next call to [Decoder.Decode].
		"""
		return go.io_Reader(handle=_game.json_Decoder_Buffered(self.handle))
	def Token(self):
		"""Token() object, str
		
		Token returns the next JSON token in the input stream.
		At the end of the input stream, Token returns nil, [io.EOF].
		
		Token guarantees that the delimiters [ ] { } it returns are
		properly nested and matched: if Token encounters an unexpected
		delimiter in the input, it will return an error.
		
		The input stream consists of basic JSON values—bool, string,
		number, and null—along with delimiters [ ] { } of type [Delim]
		to mark the start and end of arrays and objects.
		Commas and colons are elided.
		"""
		return Token(handle=_game.json_Decoder_Token(self.handle))
	def More(self):
		"""More() bool
		
		More reports whether there is another element in the
		current array or object being parsed.
		"""
		return _game.json_Decoder_More(self.handle)
	def InputOffset(self):
		"""InputOffset() long
		
		InputOffset returns the input stream byte offset of the current decoder position.
		The offset gives the location of the end of the most recently returned token
		and the beginning of the next token.
		"""
		return _game.json_Decoder_InputOffset(self.handle)

# Python type for struct json.Encoder
class Encoder(go.GoClass):
	"""An Encoder writes JSON values to an output stream.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = _game.json_Encoder_CTor()
			_game.IncRef(self.handle)
	def __del__(self):
		_game.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'json.Encoder{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'json.Encoder ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def Encode(self, v):
		"""Encode(object v) str
		
		Encode writes the JSON encoding of v to the stream,
		with insignificant space characters elided,
		followed by a newline character.
		
		See the documentation for [Marshal] for details about the
		conversion of Go values to JSON.
		"""
		return _game.json_Encoder_Encode(self.handle, v.handle)
	def SetIndent(self, prefix, indent, goRun=False):
		"""SetIndent(str prefix, str indent) 
		
		SetIndent instructs the encoder to format each subsequent encoded
		value as if indented by the package-level function Indent(dst, src, prefix, indent).
		Calling SetIndent("", "") disables indentation.
		"""
		_game.json_Encoder_SetIndent(self.handle, prefix, indent, goRun)
	def SetEscapeHTML(self, on, goRun=False):
		"""SetEscapeHTML(bool on) 
		
		SetEscapeHTML specifies whether problematic HTML characters
		should be escaped inside JSON quoted strings.
		The default behavior is to escape &, <, and > to \u0026, \u003c, and \u003e
		to avoid certain safety problems that can arise when embedding JSON in HTML.
		
		In non-HTML settings where the escaping interferes with the readability
		of the output, SetEscapeHTML(false) disables this behavior.
		"""
		_game.json_Encoder_SetEscapeHTML(self.handle, on, goRun)

# Python type for struct json.UnmarshalTypeError
class UnmarshalTypeError(go.GoClass):
	"""An UnmarshalTypeError describes a JSON value that was\nnot appropriate for a value of a specific Go type.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = _game.json_UnmarshalTypeError_CTor()
			_game.IncRef(self.handle)
			if  0 < len(args):
				self.Value = args[0]
			if "Value" in kwargs:
				self.Value = kwargs["Value"]
			if  1 < len(args):
				self.Type = args[1]
			if "Type" in kwargs:
				self.Type = kwargs["Type"]
			if  2 < len(args):
				self.Offset = args[2]
			if "Offset" in kwargs:
				self.Offset = kwargs["Offset"]
			if  3 < len(args):
				self.Struct = args[3]
			if "Struct" in kwargs:
				self.Struct = kwargs["Struct"]
			if  4 < len(args):
				self.Field = args[4]
			if "Field" in kwargs:
				self.Field = kwargs["Field"]
	def __del__(self):
		_game.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'json.UnmarshalTypeError{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'json.UnmarshalTypeError ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Value(self):
		return _game.json_UnmarshalTypeError_Value_Get(self.handle)
	@Value.setter
	def Value(self, value):
		if isinstance(value, go.GoClass):
			_game.json_UnmarshalTypeError_Value_Set(self.handle, value.handle)
		else:
			_game.json_UnmarshalTypeError_Value_Set(self.handle, value)
	@property
	def Type(self):
		return go.reflect_Type(handle=_game.json_UnmarshalTypeError_Type_Get(self.handle))
	@Type.setter
	def Type(self, value):
		if isinstance(value, go.GoClass):
			_game.json_UnmarshalTypeError_Type_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Offset(self):
		return _game.json_UnmarshalTypeError_Offset_Get(self.handle)
	@Offset.setter
	def Offset(self, value):
		if isinstance(value, go.GoClass):
			_game.json_UnmarshalTypeError_Offset_Set(self.handle, value.handle)
		else:
			_game.json_UnmarshalTypeError_Offset_Set(self.handle, value)
	@property
	def Struct(self):
		return _game.json_UnmarshalTypeError_Struct_Get(self.handle)
	@Struct.setter
	def Struct(self, value):
		if isinstance(value, go.GoClass):
			_game.json_UnmarshalTypeError_Struct_Set(self.handle, value.handle)
		else:
			_game.json_UnmarshalTypeError_Struct_Set(self.handle, value)
	@property
	def Field(self):
		return _game.json_UnmarshalTypeError_Field_Get(self.handle)
	@Field.setter
	def Field(self, value):
		if isinstance(value, go.GoClass):
			_game.json_UnmarshalTypeError_Field_Set(self.handle, value.handle)
		else:
			_game.json_UnmarshalTypeError_Field_Set(self.handle, value)
	def Error(self):
		"""Error() str"""
		return _game.json_UnmarshalTypeError_Error(self.handle)

# Python type for struct json.InvalidUnmarshalError
class InvalidUnmarshalError(go.GoClass):
	"""An InvalidUnmarshalError describes an invalid argument passed to [Unmarshal].\n(The argument to [Unmarshal] must be a non-nil pointer.)\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = _game.json_InvalidUnmarshalError_CTor()
			_game.IncRef(self.handle)
			if  0 < len(args):
				self.Type = args[0]
			if "Type" in kwargs:
				self.Type = kwargs["Type"]
	def __del__(self):
		_game.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'json.InvalidUnmarshalError{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'json.InvalidUnmarshalError ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Type(self):
		return go.reflect_Type(handle=_game.json_InvalidUnmarshalError_Type_Get(self.handle))
	@Type.setter
	def Type(self, value):
		if isinstance(value, go.GoClass):
			_game.json_InvalidUnmarshalError_Type_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def Error(self):
		"""Error() str"""
		return _game.json_InvalidUnmarshalError_Error(self.handle)

# Python type for struct json.UnmarshalFieldError
class UnmarshalFieldError(go.GoClass):
	"""An UnmarshalFieldError describes a JSON object key that\nled to an unexported (and therefore unwritable) struct field.\n\nDeprecated: No longer used; kept for compatibility.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = _game.json_UnmarshalFieldError_CTor()
			_game.IncRef(self.handle)
			if  0 < len(args):
				self.Key = args[0]
			if "Key" in kwargs:
				self.Key = kwargs["Key"]
			if  1 < len(args):
				self.Type = args[1]
			if "Type" in kwargs:
				self.Type = kwargs["Type"]
			if  2 < len(args):
				self.Field = args[2]
			if "Field" in kwargs:
				self.Field = kwargs["Field"]
	def __del__(self):
		_game.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'json.UnmarshalFieldError{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'json.UnmarshalFieldError ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Key(self):
		return _game.json_UnmarshalFieldError_Key_Get(self.handle)
	@Key.setter
	def Key(self, value):
		if isinstance(value, go.GoClass):
			_game.json_UnmarshalFieldError_Key_Set(self.handle, value.handle)
		else:
			_game.json_UnmarshalFieldError_Key_Set(self.handle, value)
	@property
	def Type(self):
		return go.reflect_Type(handle=_game.json_UnmarshalFieldError_Type_Get(self.handle))
	@Type.setter
	def Type(self, value):
		if isinstance(value, go.GoClass):
			_game.json_UnmarshalFieldError_Type_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Field(self):
		return go.reflect_StructField(handle=_game.json_UnmarshalFieldError_Field_Get(self.handle))
	@Field.setter
	def Field(self, value):
		if isinstance(value, go.GoClass):
			_game.json_UnmarshalFieldError_Field_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def Error(self):
		"""Error() str"""
		return _game.json_UnmarshalFieldError_Error(self.handle)


# ---- Slices ---

# Python type for slice json.RawMessage
class RawMessage(go.GoClass):
	"""RawMessage is a raw encoded JSON value.\nIt implements [Marshaler] and [Unmarshaler] and can\nbe used to delay JSON decoding or precompute a JSON encoding.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = _game.json_RawMessage_CTor()
			_game.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('json_RawMessage.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_game.DecRef(self.handle)
	def __str__(self):
		s = 'json.json_RawMessage len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'json.json_RawMessage([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _game.json_RawMessage_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _game.json_RawMessage_len(self.handle)
				return RawMessage(handle=_game.json_RawMessage_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _game.json_RawMessage_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_game.json_RawMessage_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('json_RawMessage.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _game.json_RawMessage_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_game.json_RawMessage_append(self.handle, value)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]
	def MarshalJSON(self):
		"""MarshalJSON() []int, str
		
		MarshalJSON returns m as the JSON encoding of m.
		"""
		return go.Slice_byte(handle=_game.json_RawMessage_MarshalJSON(self.handle))
	def UnmarshalJSON(self, data):
		"""UnmarshalJSON([]int data) str
		
		UnmarshalJSON sets *m to a copy of data.
		"""
		return _game.json_RawMessage_UnmarshalJSON(self.handle, data.handle)


# ---- Maps ---


# ---- Constructors ---
def NewDecoder(r):
	"""NewDecoder(object r) object
	
	NewDecoder returns a new decoder that reads from r.
	
	The decoder introduces its own buffering and may
	read data from r beyond the JSON values requested.
	"""
	return Decoder(handle=_game.json_NewDecoder(r.handle))
def NewEncoder(w):
	"""NewEncoder(object w) object
	
	NewEncoder returns a new encoder that writes to w.
	"""
	return Encoder(handle=_game.json_NewEncoder(w.handle))


# ---- Functions ---
def Valid(data):
	"""Valid([]int data) bool
	
	Valid reports whether data is a valid JSON encoding.
	"""
	return _game.json_Valid(data.handle)
def Compact(dst, src):
	"""Compact(object dst, []int src) str
	
	Compact appends to dst the JSON-encoded src with
	insignificant space characters elided.
	"""
	return _game.json_Compact(dst.handle, src.handle)
def MarshalIndent(v, prefix, indent):
	"""MarshalIndent(object v, str prefix, str indent) []int, str
	
	MarshalIndent is like [Marshal] but applies [Indent] to format the output.
	Each JSON element in the output will begin on a new line beginning with prefix
	followed by one or more copies of indent according to the indentation nesting.
	"""
	return go.Slice_byte(handle=_game.json_MarshalIndent(v.handle, prefix, indent))
def Marshal(v):
	"""Marshal(object v) []int, str
	
	Marshal returns the JSON encoding of v.
	
	Marshal traverses the value v recursively.
	If an encountered value implements [Marshaler]
	and is not a nil pointer, Marshal calls [Marshaler.MarshalJSON]
	to produce JSON. If no [Marshaler.MarshalJSON] method is present but the
	value implements [encoding.TextMarshaler] instead, Marshal calls
	[encoding.TextMarshaler.MarshalText] and encodes the result as a JSON string.
	The nil pointer exception is not strictly necessary
	but mimics a similar, necessary exception in the behavior of
	[Unmarshaler.UnmarshalJSON].
	
	Otherwise, Marshal uses the following type-dependent default encodings:
	
	Boolean values encode as JSON booleans.
	
	Floating point, integer, and [Number] values encode as JSON numbers.
	NaN and +/-Inf values will return an [UnsupportedValueError].
	
	String values encode as JSON strings coerced to valid UTF-8,
	replacing invalid bytes with the Unicode replacement rune.
	So that the JSON will be safe to embed inside HTML <script> tags,
	the string is encoded using [HTMLEscape],
	which replaces "<", ">", "&", U+2028, and U+2029 are escaped
	to "\u003c","\u003e", "\u0026", "\u2028", and "\u2029".
	This replacement can be disabled when using an [Encoder],
	by calling [Encoder.SetEscapeHTML](false).
	
	Array and slice values encode as JSON arrays, except that
	[]byte encodes as a base64-encoded string, and a nil slice
	encodes as the null JSON value.
	
	Struct values encode as JSON objects.
	Each exported struct field becomes a member of the object, using the
	field name as the object key, unless the field is omitted for one of the
	reasons given below.
	
	The encoding of each struct field can be customized by the format string
	stored under the "json" key in the struct field's tag.
	The format string gives the name of the field, possibly followed by a
	comma-separated list of options. The name may be empty in order to
	specify options without overriding the default field name.
	
	The "omitempty" option specifies that the field should be omitted
	from the encoding if the field has an empty value, defined as
	false, 0, a nil pointer, a nil interface value, and any empty array,
	slice, map, or string.
	
	As a special case, if the field tag is "-", the field is always omitted.
	Note that a field with name "-" can still be generated using the tag "-,".
	
	Examples of struct field tags and their meanings:
	
		// Field appears in JSON as key "myName".
		Field int `json:"myName"`
	
		// Field appears in JSON as key "myName" and
		// the field is omitted from the object if its value is empty,
		// as defined above.
		Field int `json:"myName,omitempty"`
	
		// Field appears in JSON as key "Field" (the default), but
		// the field is skipped if empty.
		// Note the leading comma.
		Field int `json:",omitempty"`
	
		// Field is ignored by this package.
		Field int `json:"-"`
	
		// Field appears in JSON as key "-".
		Field int `json:"-,"`
	
	The "string" option signals that a field is stored as JSON inside a
	JSON-encoded string. It applies only to fields of string, floating point,
	integer, or boolean types. This extra level of encoding is sometimes used
	when communicating with JavaScript programs:
	
		Int64String int64 `json:",string"`
	
	The key name will be used if it's a non-empty string consisting of
	only Unicode letters, digits, and ASCII punctuation except quotation
	marks, backslash, and comma.
	
	Embedded struct fields are usually marshaled as if their inner exported fields
	were fields in the outer struct, subject to the usual Go visibility rules amended
	as described in the next paragraph.
	An anonymous struct field with a name given in its JSON tag is treated as
	having that name, rather than being anonymous.
	An anonymous struct field of interface type is treated the same as having
	that type as its name, rather than being anonymous.
	
	The Go visibility rules for struct fields are amended for JSON when
	deciding which field to marshal or unmarshal. If there are
	multiple fields at the same level, and that level is the least
	nested (and would therefore be the nesting level selected by the
	usual Go rules), the following extra rules apply:
	
	1) Of those fields, if any are JSON-tagged, only tagged fields are considered,
	even if there are multiple untagged fields that would otherwise conflict.
	
	2) If there is exactly one field (tagged or not according to the first rule), that is selected.
	
	3) Otherwise there are multiple fields, and all are ignored; no error occurs.
	
	Handling of anonymous struct fields is new in Go 1.1.
	Prior to Go 1.1, anonymous struct fields were ignored. To force ignoring of
	an anonymous struct field in both current and earlier versions, give the field
	a JSON tag of "-".
	
	Map values encode as JSON objects. The map's key type must either be a
	string, an integer type, or implement [encoding.TextMarshaler]. The map keys
	are sorted and used as JSON object keys by applying the following rules,
	subject to the UTF-8 coercion described for string values above:
	  - keys of any string type are used directly
	  - keys that implement [encoding.TextMarshaler] are marshaled
	  - integer keys are converted to strings
	
	Pointer values encode as the value pointed to.
	A nil pointer encodes as the null JSON value.
	
	Interface values encode as the value contained in the interface.
	A nil interface value encodes as the null JSON value.
	
	Channel, complex, and function values cannot be encoded in JSON.
	Attempting to encode such a value causes Marshal to return
	an [UnsupportedTypeError].
	
	JSON cannot represent cyclic data structures and Marshal does not
	handle them. Passing cyclic structures to Marshal will result in
	an error.
	"""
	return go.Slice_byte(handle=_game.json_Marshal(v.handle))
def Unmarshal(data, v):
	"""Unmarshal([]int data, object v) str
	
	Unmarshal parses the JSON-encoded data and stores the result
	in the value pointed to by v. If v is nil or not a pointer,
	Unmarshal returns an [InvalidUnmarshalError].
	
	Unmarshal uses the inverse of the encodings that
	[Marshal] uses, allocating maps, slices, and pointers as necessary,
	with the following additional rules:
	
	To unmarshal JSON into a pointer, Unmarshal first handles the case of
	the JSON being the JSON literal null. In that case, Unmarshal sets
	the pointer to nil. Otherwise, Unmarshal unmarshals the JSON into
	the value pointed at by the pointer. If the pointer is nil, Unmarshal
	allocates a new value for it to point to.
	
	To unmarshal JSON into a value implementing [Unmarshaler],
	Unmarshal calls that value's [Unmarshaler.UnmarshalJSON] method, including
	when the input is a JSON null.
	Otherwise, if the value implements [encoding.TextUnmarshaler]
	and the input is a JSON quoted string, Unmarshal calls
	[encoding.TextUnmarshaler.UnmarshalText] with the unquoted form of the string.
	
	To unmarshal JSON into a struct, Unmarshal matches incoming object
	keys to the keys used by [Marshal] (either the struct field name or its tag),
	preferring an exact match but also accepting a case-insensitive match. By
	default, object keys which don't have a corresponding struct field are
	ignored (see [Decoder.DisallowUnknownFields] for an alternative).
	
	To unmarshal JSON into an interface value,
	Unmarshal stores one of these in the interface value:
	
	  - bool, for JSON booleans
	  - float64, for JSON numbers
	  - string, for JSON strings
	  - []interface{}, for JSON arrays
	  - map[string]interface{}, for JSON objects
	  - nil for JSON null
	
	To unmarshal a JSON array into a slice, Unmarshal resets the slice length
	to zero and then appends each element to the slice.
	As a special case, to unmarshal an empty JSON array into a slice,
	Unmarshal replaces the slice with a new empty slice.
	
	To unmarshal a JSON array into a Go array, Unmarshal decodes
	JSON array elements into corresponding Go array elements.
	If the Go array is smaller than the JSON array,
	the additional JSON array elements are discarded.
	If the JSON array is smaller than the Go array,
	the additional Go array elements are set to zero values.
	
	To unmarshal a JSON object into a map, Unmarshal first establishes a map to
	use. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal
	reuses the existing map, keeping existing entries. Unmarshal then stores
	key-value pairs from the JSON object into the map. The map's key type must
	either be any string type, an integer, or implement [encoding.TextUnmarshaler].
	
	If the JSON-encoded data contain a syntax error, Unmarshal returns a [SyntaxError].
	
	If a JSON value is not appropriate for a given target type,
	or if a JSON number overflows the target type, Unmarshal
	skips that field and completes the unmarshaling as best it can.
	If no more serious errors are encountered, Unmarshal returns
	an [UnmarshalTypeError] describing the earliest such error. In any
	case, it's not guaranteed that all the remaining fields following
	the problematic one will be unmarshaled into the target object.
	
	The JSON null value unmarshals into an interface, map, pointer, or slice
	by setting that Go value to nil. Because null is often used in JSON to mean
	“not present,” unmarshaling a JSON null into any other Go type has no effect
	on the value and produces no error.
	
	When unmarshaling quoted strings, invalid UTF-8 or
	invalid UTF-16 surrogate pairs are not treated as an error.
	Instead, they are replaced by the Unicode replacement
	character U+FFFD.
	"""
	return _game.json_Unmarshal(data.handle, v.handle)
def HTMLEscape(dst, src, goRun=False):
	"""HTMLEscape(object dst, []int src) 
	
	HTMLEscape appends to dst the JSON-encoded src with <, >, &, U+2028 and U+2029
	characters inside string literals changed to \u003c, \u003e, \u0026, \u2028, \u2029
	so that the JSON will be safe to embed inside HTML <script> tags.
	For historical reasons, web browsers don't honor standard HTML
	escaping within <script> tags, so an alternative JSON encoding must be used.
	"""
	_game.json_HTMLEscape(dst.handle, src.handle, goRun)
def Indent(dst, src, prefix, indent):
	"""Indent(object dst, []int src, str prefix, str indent) str
	
	Indent appends to dst an indented form of the JSON-encoded src.
	Each element in a JSON object or array begins on a new,
	indented line beginning with prefix followed by one or more
	copies of indent according to the indentation nesting.
	The data appended to dst does not begin with the prefix nor
	any indentation, to make it easier to embed inside other formatted JSON data.
	Although leading space characters (space, tab, carriage return, newline)
	at the beginning of src are dropped, trailing space characters
	at the end of src are preserved and copied to dst.
	For example, if src has no trailing spaces, neither will dst;
	if src ends in a trailing newline, so will dst.
	"""
	return _game.json_Indent(dst.handle, src.handle, prefix, indent)


