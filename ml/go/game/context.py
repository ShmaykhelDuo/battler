"""
Package context defines the Context type, which carries deadlines,
cancellation signals, and other request-scoped values across API boundaries
and between processes.

Incoming requests to a server should create a [Context], and outgoing
calls to servers should accept a Context. The chain of function
calls between them must propagate the Context, optionally replacing
it with a derived Context created using [WithCancel], [WithDeadline],
[WithTimeout], or [WithValue]. When a Context is canceled, all
Contexts derived from it are also canceled.

The [WithCancel], [WithDeadline], and [WithTimeout] functions take a
Context (the parent) and return a derived Context (the child) and a
[CancelFunc]. Calling the CancelFunc cancels the child and its
children, removes the parent's reference to the child, and stops
any associated timers. Failing to call the CancelFunc leaks the
child and its children until the parent is canceled or the timer
fires. The go vet tool checks that CancelFuncs are used on all
control-flow paths.

The [WithCancelCause] function returns a [CancelCauseFunc], which
takes an error and records it as the cancellation cause. Calling
[Cause] on the canceled context or any of its children retrieves
the cause. If no cause is specified, Cause(ctx) returns the same
value as ctx.Err().

Programs that use Contexts should follow these rules to keep interfaces
consistent across packages and enable static analysis tools to check context
propagation:

Do not store Contexts inside a struct type; instead, pass a Context
explicitly to each function that needs it. The Context should be the first
parameter, typically named ctx:

	func DoSomething(ctx context.Context, arg Arg) error {
		// ... use ctx ...
	}

Do not pass a nil [Context], even if a function permits it. Pass [context.TODO]
if you are unsure about which Context to use.

Use context Values only for request-scoped data that transits processes and
APIs, not for passing optional parameters to functions.

The same Context may be passed to functions running in different goroutines;
Contexts are safe for simultaneous use by multiple goroutines.

See https://blog.golang.org/context for example code for a server that uses
Contexts.

"""
# python wrapper for package context within overall package game
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy pkg -exclude=model,ml1,ml2,moveml ../../internal/game ../../internal/bot context encoding/json

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _game
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from game import context
# and then refer to everything using context. prefix
# packages imported by this package listed below:




# ---- Types ---


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---

# Python type for interface context.Context
class Context(go.GoClass):
	"""A Context carries a deadline, a cancellation signal, and other values across\nAPI boundaries.\n\nContext's methods may be called by multiple goroutines simultaneously.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = 0
	def Err(self):
		"""Err() str"""
		return _game.context_Context_Err(self.handle)
	def Value(self, key):
		"""Value(object key) object"""
		return any(handle=_game.context_Context_Value(self.handle, key.handle))


# ---- Structs ---


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---


# ---- Functions ---
def WithoutCancel(parent):
	"""WithoutCancel(object parent) object
	
	WithoutCancel returns a copy of parent that is not canceled when parent is canceled.
	The returned context returns no Deadline or Err, and its Done channel is nil.
	Calling [Cause] on the returned context returns nil.
	"""
	return Context(handle=_game.context_WithoutCancel(parent.handle))
def Background():
	"""Background() object
	
	Background returns a non-nil, empty [Context]. It is never canceled, has no
	values, and has no deadline. It is typically used by the main function,
	initialization, and tests, and as the top-level Context for incoming
	requests.
	"""
	return Context(handle=_game.context_Background())
def Cause(c):
	"""Cause(object c) str
	
	Cause returns a non-nil error explaining why c was canceled.
	The first cancellation of c or one of its parents sets the cause.
	If that cancellation happened via a call to CancelCauseFunc(err),
	then [Cause] returns err.
	Otherwise Cause(c) returns the same value as c.Err().
	Cause returns nil if c has not been canceled yet.
	"""
	return _game.context_Cause(c.handle)
def TODO():
	"""TODO() object
	
	TODO returns a non-nil, empty [Context]. Code should use context.TODO when
	it's unclear which Context to use or it is not yet available (because the
	surrounding function has not yet been extended to accept a Context
	parameter).
	"""
	return Context(handle=_game.context_TODO())
def WithValue(parent, key, val):
	"""WithValue(object parent, object key, object val) object
	
	WithValue returns a copy of parent in which the value associated with key is
	val.
	
	Use context Values only for request-scoped data that transits processes and
	APIs, not for passing optional parameters to functions.
	
	The provided key must be comparable and should not be of type
	string or any other built-in type to avoid collisions between
	packages using context. Users of WithValue should define their own
	types for keys. To avoid allocating when assigning to an
	interface{}, context keys often have concrete type
	struct{}. Alternatively, exported context key variables' static
	type should be a pointer or interface.
	"""
	return Context(handle=_game.context_WithValue(parent.handle, key.handle, val.handle))


