
# python wrapper for package github.com/ShmaykhelDuo/battler/internal/game within overall package game
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy pkg -exclude=model,ml1,ml2,moveml ../../internal/game ../../internal/bot context encoding/json

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _game
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from game import game
# and then refer to everything using game. prefix
# packages imported by this package listed below:




# ---- Types ---

# Python type for slice [4]*game.Skill
class Array_4_Ptr_game_Skill(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
	def __del__(self):
		_game.DecRef(self.handle)
	def __str__(self):
		s = 'game.Array_4_Ptr_game_Skill len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'game.Array_4_Ptr_game_Skill([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _game.Array_4_Ptr_game_Skill_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Skill(handle=_game.Array_4_Ptr_game_Skill_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_game.Array_4_Ptr_game_Skill_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Skill(handle=_game.Array_4_Ptr_game_Skill_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration

# Python type for slice [4]*game.SkillData
class Array_4_Ptr_game_SkillData(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
	def __del__(self):
		_game.DecRef(self.handle)
	def __str__(self):
		s = 'game.Array_4_Ptr_game_SkillData len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'game.Array_4_Ptr_game_SkillData([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _game.Array_4_Ptr_game_SkillData_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return SkillData(handle=_game.Array_4_Ptr_game_SkillData_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_game.Array_4_Ptr_game_SkillData_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = SkillData(handle=_game.Array_4_Ptr_game_SkillData_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration

# Python type for slice []game.Colour
class Slice_game_Colour(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = _game.Slice_game_Colour_CTor()
			_game.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_game_Colour.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_game.DecRef(self.handle)
	def __str__(self):
		s = 'game.Slice_game_Colour len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'game.Slice_game_Colour([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _game.Slice_game_Colour_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _game.Slice_game_Colour_len(self.handle)
				return Slice_game_Colour(handle=_game.Slice_game_Colour_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _game.Slice_game_Colour_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_game.Slice_game_Colour_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_game_Colour.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _game.Slice_game_Colour_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_game.Slice_game_Colour_append(self.handle, value)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []game.Effect
class Slice_game_Effect(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = _game.Slice_game_Effect_CTor()
			_game.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_game_Effect.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_game.DecRef(self.handle)
	def __str__(self):
		s = 'game.Slice_game_Effect len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'game.Slice_game_Effect([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _game.Slice_game_Effect_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _game.Slice_game_Effect_len(self.handle)
				return Slice_game_Effect(handle=_game.Slice_game_Effect_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Effect(handle=_game.Slice_game_Effect_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_game.Slice_game_Effect_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_game_Effect.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Effect(handle=_game.Slice_game_Effect_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_game.Slice_game_Effect_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for map map[game.Colour]int
class Map_game_Colour_int(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = _game.Map_game_Colour_int_CTor()
			_game.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_game_Colour_int.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_game.Map_game_Colour_int_set(self.handle, k, v)
	def __del__(self):
		_game.DecRef(self.handle)
	def __str__(self):
		s = 'game.Map_game_Colour_int len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'game.Map_game_Colour_int({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _game.Map_game_Colour_int_len(self.handle)
	def __getitem__(self, key):
		return _game.Map_game_Colour_int_elem(self.handle, key)
	def __setitem__(self, key, value):
		_game.Map_game_Colour_int_set(self.handle, key, value)
	def __delitem__(self, key):
		return _game.Map_game_Colour_int_delete(self.handle, key)
	def keys(self):
		return Slice_game_Colour(handle=_game.Map_game_Colour_int_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _game.Map_game_Colour_int_contains(self.handle, key)


#---- Enums from Go (collections of consts with same type) ---
from enum import Enum

class Colour(Enum):
	"""
	Colour represents a colour in the game.
	
	"""
	ColourNone = 0
	ColourRed = 1
	ColourOrange = 2
	ColourYellow = 3
	ColourGreen = 4
	ColourCyan = 5
	ColourBlue = 6
	ColourViolet = 7
	ColourPink = 8
	ColourGray = 9
	ColourBrown = 10
	ColourBlack = 11
	ColourWhite = 12

ColourNone = 0
ColourRed = 1
ColourOrange = 2
ColourYellow = 3
ColourGreen = 4
ColourCyan = 5
ColourBlue = 6
ColourViolet = 7
ColourPink = 8
ColourGray = 9
ColourBrown = 10
ColourBlack = 11
ColourWhite = 12

class EffectType(Enum):
	"""
	EffectType represents a type of an effect.
	
	"""
	EffectTypeBasic = 0
	EffectTypeProhibiting = 1
	EffectTypeControl = 2
	EffectTypeBuff = 3
	EffectTypeDebuff = 4
	EffectTypeState = 5
	EffectTypeNumeric = 6

EffectTypeBasic = 0
EffectTypeProhibiting = 1
EffectTypeControl = 2
EffectTypeBuff = 3
EffectTypeDebuff = 4
EffectTypeState = 5
EffectTypeNumeric = 6



#---- Constants from Go: Python can only ask that you please don't change these! ---
MaxTurnNumber = 10
MinTurnNumber = 1
SkillCount = 4
"""
SkillCount is a number of skills provided by a character.

"""


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---

# Python type for interface game.DealtDamageModifier
class DealtDamageModifier(go.GoClass):
	"""DealtDamageModifier modifies the amount of damage for a character to deal.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = 0
	def ModifyDealtDamage(self, dmg, colour):
		"""ModifyDealtDamage(int dmg, int colour) int"""
		return _game.game_DealtDamageModifier_ModifyDealtDamage(self.handle, dmg, colour)

# Python type for interface game.EffectFilter
class EffectFilter(go.GoClass):
	"""EffectFilter filters effects allowed to be applied to a character.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = 0
	def IsEffectAllowed(self, e):
		"""IsEffectAllowed(object e) bool"""
		return _game.game_EffectFilter_IsEffectAllowed(self.handle, e.handle)

# Python type for interface game.HealFilter
class HealFilter(go.GoClass):
	"""HealFilter filters healing of a character.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = 0
	def IsHealAllowed(self, heal):
		"""IsHealAllowed(int heal) bool"""
		return _game.game_HealFilter_IsHealAllowed(self.handle, heal)

# Python type for interface game.SkillUnlockTurnModifier
class SkillUnlockTurnModifier(go.GoClass):
	"""SkillUnlockTurnModifier modified the turn number when skill is to be unlocked.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = 0
	def ModifySkillUnlockTurn(self, s, unlockTurn):
		"""ModifySkillUnlockTurn(object s, int unlockTurn) int"""
		return _game.game_SkillUnlockTurnModifier_ModifySkillUnlockTurn(self.handle, s.handle, unlockTurn)

# Python type for interface game.SkillAvailabilityFilter
class SkillAvailabilityFilter(go.GoClass):
	"""SkillAvailabilityFilter filters skills to be used by a character.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = 0
	def IsSkillAvailable(self, s):
		"""IsSkillAvailable(object s) bool"""
		return _game.game_SkillAvailabilityFilter_IsSkillAvailable(self.handle, s.handle)

# Python type for interface game.SkillsPerTurnHandler
class SkillsPerTurnHandler(go.GoClass):
	"""SkillsPerTurnHandler handles changing number of skills per turn.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = 0
	def SkillsPerTurn(self):
		"""SkillsPerTurn() int"""
		return _game.game_SkillsPerTurnHandler_SkillsPerTurn(self.handle)

# Python type for interface game.TakenDamageModifier
class TakenDamageModifier(go.GoClass):
	"""TakenDamageModifier modifies the amount of damage for a character to take.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = 0
	def ModifyTakenDamage(self, dmg, colour):
		"""ModifyTakenDamage(int dmg, int colour) int"""
		return _game.game_TakenDamageModifier_ModifyTakenDamage(self.handle, dmg, colour)

# Python type for interface game.TurnEndHandler
class TurnEndHandler(go.GoClass):
	"""TurnEndHandler handles the end-of-turn action.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = 0
	def OnTurnEnd(self, c, opp, turnState, goRun=False):
		"""OnTurnEnd(object c, object opp, object turnState) """
		_game.game_TurnEndHandler_OnTurnEnd(self.handle, c.handle, opp.handle, turnState.handle, goRun)

# Python type for interface game.ControlHandler
class ControlHandler(go.GoClass):
	"""ControlHandler handles taking control of the character.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = 0
	def HasTakenControl(self):
		"""HasTakenControl() bool"""
		return _game.game_ControlHandler_HasTakenControl(self.handle)

# Python type for interface game.DefenceModifier
class DefenceModifier(go.GoClass):
	"""DefenceModifier modifies a character's defences.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = 0
	def ModifyDefences(self, mydef, goRun=False):
		"""ModifyDefences(object def) """
		_game.game_DefenceModifier_ModifyDefences(self.handle, mydef.handle, goRun)

# Python type for interface game.Effect
class Effect(go.GoClass):
	"""Effect represents an effect to be applied to a character.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = 0
	def Clone(self):
		"""Clone() object"""
		return Effect(handle=_game.game_Effect_Clone(self.handle))
	def Desc(self):
		"""Desc() object"""
		return EffectDescription(handle=_game.game_Effect_Desc(self.handle))

# Python type for interface game.Expirable
class Expirable(go.GoClass):
	"""Expirable represents an effect which can be expired.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = 0
	def HasExpired(self, turnState):
		"""HasExpired(object turnState) bool"""
		return _game.game_Expirable_HasExpired(self.handle, turnState.handle)


# ---- Structs ---

# Python type for struct game.EffectDescription
class EffectDescription(go.GoClass):
	"""EffectDescription contains main features of an effect.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = _game.game_EffectDescription_CTor()
			_game.IncRef(self.handle)
			if  0 < len(args):
				self.Name = args[0]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  1 < len(args):
				self.Type = args[1]
			if "Type" in kwargs:
				self.Type = kwargs["Type"]
	def __del__(self):
		_game.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'game.EffectDescription{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'game.EffectDescription ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Name(self):
		return _game.game_EffectDescription_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_game.game_EffectDescription_Name_Set(self.handle, value.handle)
		else:
			_game.game_EffectDescription_Name_Set(self.handle, value)
	@property
	def Type(self):
		return _game.game_EffectDescription_Type_Get(self.handle)
	@Type.setter
	def Type(self, value):
		if isinstance(value, go.GoClass):
			_game.game_EffectDescription_Type_Set(self.handle, value.handle)
		else:
			_game.game_EffectDescription_Type_Set(self.handle, value)

# Python type for struct game.Skill
class Skill(go.GoClass):
	"""Skill is a representation of a skill of a character in a match.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = _game.game_Skill_CTor()
			_game.IncRef(self.handle)
	def __del__(self):
		_game.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'game.Skill{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'game.Skill ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def Desc(self):
		"""Desc() object
		
		Desc returns the skill's description.
		"""
		return SkillDescription(handle=_game.game_Skill_Desc(self.handle))
	def Cooldown(self):
		"""Cooldown() int
		
		Cooldown returns the skill's cooldown.
		Returns 0 when no cooldown is applicable to the skill.
		"""
		return _game.game_Skill_Cooldown(self.handle)
	def UnlockTurn(self, c):
		"""UnlockTurn(object c) int
		
		UnlockTurn returns the turn number when the skill is to be unlocked.
		Returns 0 when skill is unlocked from the beginning of the game.
		The value can be modified by the character's effects.
		"""
		return _game.game_Skill_UnlockTurn(self.handle, c.handle)
	def IsAvailable(self, c, opp, turnState):
		"""IsAvailable(object c, object opp, object turnState) bool
		
		IsAvailable reports whether the skill is available.
		Unlock turn number, cooldown and effects are taken into account.
		"""
		return _game.game_Skill_IsAvailable(self.handle, c.handle, opp.handle, turnState.handle)
	def Use(self, c, opp, turnState):
		"""Use(object c, object opp, object turnState) str
		
		Use executes the skill's action.
		Returns [ErrSkillNotAvailable] when the skill is not available for use.
		"""
		return _game.game_Skill_Use(self.handle, c.handle, opp.handle, turnState.handle)
	def IsAppropriate(self, c, opp, turnState):
		"""IsAppropriate(object c, object opp, object turnState) bool"""
		return _game.game_Skill_IsAppropriate(self.handle, c.handle, opp.handle, turnState.handle)

# Python type for struct game.SkillData
class SkillData(go.GoClass):
	"""SkillData is a list of features of a skill.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = _game.game_SkillData_CTor()
			_game.IncRef(self.handle)
			if  0 < len(args):
				self.Desc = args[0]
			if "Desc" in kwargs:
				self.Desc = kwargs["Desc"]
			if  1 < len(args):
				self.Cooldown = args[1]
			if "Cooldown" in kwargs:
				self.Cooldown = kwargs["Cooldown"]
			if  2 < len(args):
				self.UnlockTurn = args[2]
			if "UnlockTurn" in kwargs:
				self.UnlockTurn = kwargs["UnlockTurn"]
	def __del__(self):
		_game.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'game.SkillData{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'game.SkillData ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Desc(self):
		return SkillDescription(handle=_game.game_SkillData_Desc_Get(self.handle))
	@Desc.setter
	def Desc(self, value):
		if isinstance(value, go.GoClass):
			_game.game_SkillData_Desc_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Cooldown(self):
		return _game.game_SkillData_Cooldown_Get(self.handle)
	@Cooldown.setter
	def Cooldown(self, value):
		if isinstance(value, go.GoClass):
			_game.game_SkillData_Cooldown_Set(self.handle, value.handle)
		else:
			_game.game_SkillData_Cooldown_Set(self.handle, value)
	@property
	def UnlockTurn(self):
		return _game.game_SkillData_UnlockTurn_Get(self.handle)
	@UnlockTurn.setter
	def UnlockTurn(self, value):
		if isinstance(value, go.GoClass):
			_game.game_SkillData_UnlockTurn_Set(self.handle, value.handle)
		else:
			_game.game_SkillData_UnlockTurn_Set(self.handle, value)

# Python type for struct game.SkillDescription
class SkillDescription(go.GoClass):
	"""SkillDescription is a list of constant features of a skill.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = _game.game_SkillDescription_CTor()
			_game.IncRef(self.handle)
			if  0 < len(args):
				self.Name = args[0]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  1 < len(args):
				self.Colour = args[1]
			if "Colour" in kwargs:
				self.Colour = kwargs["Colour"]
			if  2 < len(args):
				self.IsUltimate = args[2]
			if "IsUltimate" in kwargs:
				self.IsUltimate = kwargs["IsUltimate"]
	def __del__(self):
		_game.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'game.SkillDescription{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'game.SkillDescription ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Name(self):
		return _game.game_SkillDescription_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_game.game_SkillDescription_Name_Set(self.handle, value.handle)
		else:
			_game.game_SkillDescription_Name_Set(self.handle, value)
	@property
	def Colour(self):
		return _game.game_SkillDescription_Colour_Get(self.handle)
	@Colour.setter
	def Colour(self, value):
		if isinstance(value, go.GoClass):
			_game.game_SkillDescription_Colour_Set(self.handle, value.handle)
		else:
			_game.game_SkillDescription_Colour_Set(self.handle, value)
	@property
	def IsUltimate(self):
		return _game.game_SkillDescription_IsUltimate_Get(self.handle)
	@IsUltimate.setter
	def IsUltimate(self, value):
		if isinstance(value, go.GoClass):
			_game.game_SkillDescription_IsUltimate_Set(self.handle, value.handle)
		else:
			_game.game_SkillDescription_IsUltimate_Set(self.handle, value)

# Python type for struct game.TurnState
class TurnState(go.GoClass):
	"""TurnState contains any additional data needed to be used.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = _game.game_TurnState_CTor()
			_game.IncRef(self.handle)
			if  0 < len(args):
				self.TurnNum = args[0]
			if "TurnNum" in kwargs:
				self.TurnNum = kwargs["TurnNum"]
			if  1 < len(args):
				self.IsGoingFirst = args[1]
			if "IsGoingFirst" in kwargs:
				self.IsGoingFirst = kwargs["IsGoingFirst"]
			if  2 < len(args):
				self.IsTurnEnd = args[2]
			if "IsTurnEnd" in kwargs:
				self.IsTurnEnd = kwargs["IsTurnEnd"]
	def __del__(self):
		_game.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'game.TurnState{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'game.TurnState ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def TurnNum(self):
		return _game.game_TurnState_TurnNum_Get(self.handle)
	@TurnNum.setter
	def TurnNum(self, value):
		if isinstance(value, go.GoClass):
			_game.game_TurnState_TurnNum_Set(self.handle, value.handle)
		else:
			_game.game_TurnState_TurnNum_Set(self.handle, value)
	@property
	def IsGoingFirst(self):
		return _game.game_TurnState_IsGoingFirst_Get(self.handle)
	@IsGoingFirst.setter
	def IsGoingFirst(self, value):
		if isinstance(value, go.GoClass):
			_game.game_TurnState_IsGoingFirst_Set(self.handle, value.handle)
		else:
			_game.game_TurnState_IsGoingFirst_Set(self.handle, value)
	@property
	def IsTurnEnd(self):
		return _game.game_TurnState_IsTurnEnd_Get(self.handle)
	@IsTurnEnd.setter
	def IsTurnEnd(self, value):
		if isinstance(value, go.GoClass):
			_game.game_TurnState_IsTurnEnd_Set(self.handle, value.handle)
		else:
			_game.game_TurnState_IsTurnEnd_Set(self.handle, value)
	def WithGoingFirst(self, isGoingFirst):
		"""WithGoingFirst(bool isGoingFirst) object
		
		WithGoingFirst returns a copy of the state with going first set.
		"""
		return TurnState(handle=_game.game_TurnState_WithGoingFirst(self.handle, isGoingFirst))
	def WithTurnEnd(self):
		"""WithTurnEnd() object
		
		WithTurnEnd returns a copy of the state with turn end set.
		"""
		return TurnState(handle=_game.game_TurnState_WithTurnEnd(self.handle))
	def IsAfter(self, other):
		"""IsAfter(object other) bool
		
		IsAfter reports whether the current context is indicating later game time than provided context.
		"""
		return _game.game_TurnState_IsAfter(self.handle, other.handle)
	def AddTurns(self, turns, isOpponentsTurn):
		"""AddTurns(int turns, bool isOpponentsTurn) object
		
		AddTurns returns the context of provided number of turns ahead.
		Is isOpponentsTurn is true, the returned context is of the nearest opponent's turn.
		"""
		return TurnState(handle=_game.game_TurnState_AddTurns(self.handle, turns, isOpponentsTurn))
	def Next(self):
		"""Next() object"""
		return TurnState(handle=_game.game_TurnState_Next(self.handle))

# Python type for struct game.Character
class Character(go.GoClass):
	"""Character is a representation of a character in a match.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = _game.game_Character_CTor()
			_game.IncRef(self.handle)
	def __del__(self):
		_game.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'game.Character{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'game.Character ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def Desc(self):
		"""Desc() object
		
		Desc returns the character's description.
		"""
		return CharacterDescription(handle=_game.game_Character_Desc(self.handle))
	def HP(self):
		"""HP() int
		
		HP returns the character's current HP.
		"""
		return _game.game_Character_HP(self.handle)
	def MaxHP(self):
		"""MaxHP() int
		
		MaxHP returns the character's current maximum HP.
		"""
		return _game.game_Character_MaxHP(self.handle)
	def Defences(self):
		"""Defences() object
		
		Defences returns a map of the character's defences for each colour.
		Defence is a modifier which is subtracted from damage of specific colour.
		"""
		return Map_game_Colour_int(handle=_game.game_Character_Defences(self.handle))
	def Effects(self):
		"""Effects() []object
		
		Effects returns a slice of effects applied to the character.
		"""
		return Slice_game_Effect(handle=_game.game_Character_Effects(self.handle))
	def Skills(self):
		"""Skills() []object
		
		Skills returns an array of skills provided by the character.
		"""
		return Array_4_Ptr_game_Skill(handle=_game.game_Character_Skills(self.handle))
	def LastUsedSkill(self):
		"""LastUsedSkill() object
		
		LastUsedSkill returns the skill used last.
		"""
		return Skill(handle=_game.game_Character_LastUsedSkill(self.handle))
	def IsControlledByOpp(self):
		"""IsControlledByOpp() bool
		
		IsControlledByOpp reports whether the opponent is in control of the character.
		"""
		return _game.game_Character_IsControlledByOpp(self.handle)
	def SkillsPerTurn(self):
		"""SkillsPerTurn() int
		
		SkillsPerTurn return a number of times a skill can be used this turn.
		"""
		return _game.game_Character_SkillsPerTurn(self.handle)
	def SetMaxHP(self, maxHP, goRun=False):
		"""SetMaxHP(int maxHP) 
		
		SetMaxHP sets the character's maximum HP.
		If the new value is less than the character's HP, HP is decreased to match maximum HP.
		"""
		_game.game_Character_SetMaxHP(self.handle, maxHP, goRun)
	def AddEffect(self, eff, goRun=False):
		"""AddEffect(object eff) 
		
		AddEffect applies an effect to the character.
		The effect can be blocked by any of effects already applied to the character.
		"""
		_game.game_Character_AddEffect(self.handle, eff.handle, goRun)
	def Damage(self, opp, dmg, colour):
		"""Damage(object opp, int dmg, int colour) int
		
		Damage decreases the opponent's HP.
		It returns the actual amount of damage taken by the opponent.
		The actual amount of damage is affected by the character's and opponent's effects and opponent's defences.
		"""
		return _game.game_Character_Damage(self.handle, opp.handle, dmg, colour)
	def Kill(self, goRun=False):
		"""Kill() 
		
		Kill immediately kills the character.
		"""
		_game.game_Character_Kill(self.handle, goRun)
	def CanHeal(self, heal):
		"""CanHeal(int heal) bool"""
		return _game.game_Character_CanHeal(self.handle, heal)
	def Heal(self, heal):
		"""Heal(int heal) int
		
		Heal increases the character's HP.
		It returns the actual amount of healing applied to the character.
		Healing can be blocked by any of the effects applied to the character.
		"""
		return _game.game_Character_Heal(self.handle, heal)
	def OnTurnEnd(self, opp, turnState, goRun=False):
		"""OnTurnEnd(object opp, object turnState) 
		
		OnTurnEnd triggers all the end-of-turn actions provided by effects applied to the character.
		"""
		_game.game_Character_OnTurnEnd(self.handle, opp.handle, turnState.handle, goRun)
	def Clone(self):
		"""Clone() object
		
		Clones returns a deep clone of the character.
		"""
		return Character(handle=_game.game_Character_Clone(self.handle))
	def CloneWithSkill(self, i):
		"""CloneWithSkill(int i) object
		
		Clones returns a deep clone of the character.
		"""
		return Character(handle=_game.game_Character_CloneWithSkill(self.handle, i))
	def CloneWithoutSkills(self):
		"""CloneWithoutSkills() object
		
		Clones returns a deep clone of the character.
		"""
		return Character(handle=_game.game_Character_CloneWithoutSkills(self.handle))

# Python type for struct game.CharacterData
class CharacterData(go.GoClass):
	"""CharacterData is a list of features of a character.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = _game.game_CharacterData_CTor()
			_game.IncRef(self.handle)
			if  0 < len(args):
				self.SkillData = args[0]
			if "SkillData" in kwargs:
				self.SkillData = kwargs["SkillData"]
			if  1 < len(args):
				self.Desc = args[1]
			if "Desc" in kwargs:
				self.Desc = kwargs["Desc"]
			if  2 < len(args):
				self.DefaultHP = args[2]
			if "DefaultHP" in kwargs:
				self.DefaultHP = kwargs["DefaultHP"]
			if  3 < len(args):
				self.Defences = args[3]
			if "Defences" in kwargs:
				self.Defences = kwargs["Defences"]
	def __del__(self):
		_game.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'game.CharacterData{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'game.CharacterData ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def SkillData(self):
		return Array_4_Ptr_game_SkillData(handle=_game.game_CharacterData_SkillData_Get(self.handle))
	@property
	def Desc(self):
		return CharacterDescription(handle=_game.game_CharacterData_Desc_Get(self.handle))
	@Desc.setter
	def Desc(self, value):
		if isinstance(value, go.GoClass):
			_game.game_CharacterData_Desc_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def DefaultHP(self):
		return _game.game_CharacterData_DefaultHP_Get(self.handle)
	@DefaultHP.setter
	def DefaultHP(self, value):
		if isinstance(value, go.GoClass):
			_game.game_CharacterData_DefaultHP_Set(self.handle, value.handle)
		else:
			_game.game_CharacterData_DefaultHP_Set(self.handle, value)
	@property
	def Defences(self):
		return Map_game_Colour_int(handle=_game.game_CharacterData_Defences_Get(self.handle))
	@Defences.setter
	def Defences(self, value):
		if isinstance(value, go.GoClass):
			_game.game_CharacterData_Defences_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct game.CharacterDescription
class CharacterDescription(go.GoClass):
	"""CharacterDescription is a list of constant features of a character.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_game.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_game.IncRef(self.handle)
		else:
			self.handle = _game.game_CharacterDescription_CTor()
			_game.IncRef(self.handle)
			if  0 < len(args):
				self.Name = args[0]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  1 < len(args):
				self.Number = args[1]
			if "Number" in kwargs:
				self.Number = kwargs["Number"]
	def __del__(self):
		_game.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'game.CharacterDescription{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'game.CharacterDescription ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Name(self):
		return _game.game_CharacterDescription_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_game.game_CharacterDescription_Name_Set(self.handle, value.handle)
		else:
			_game.game_CharacterDescription_Name_Set(self.handle, value)
	@property
	def Number(self):
		return _game.game_CharacterDescription_Number_Get(self.handle)
	@Number.setter
	def Number(self, value):
		if isinstance(value, go.GoClass):
			_game.game_CharacterDescription_Number_Set(self.handle, value.handle)
		else:
			_game.game_CharacterDescription_Number_Set(self.handle, value)


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---
def NewSkill(data):
	"""NewSkill(object data) object
	
	NewSkill returns a new skill composed using provided character and data.
	"""
	return Skill(handle=_game.game_NewSkill(data.handle))
def StartTurnState():
	"""StartTurnState() object"""
	return TurnState(handle=_game.game_StartTurnState())
def NewTurnState(turnNum):
	"""NewTurnState(int turnNum) object
	
	NewTurnState returns a new [TurnState] with provided turn number.
	"""
	return TurnState(handle=_game.game_NewTurnState(turnNum))
def NewCharacter(data):
	"""NewCharacter(object data) object
	
	NewCharacter returns a new character composed using provided data.
	"""
	return Character(handle=_game.game_NewCharacter(data.handle))


# ---- Functions ---


